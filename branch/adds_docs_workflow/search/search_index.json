{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Catalyst Forge","text":"<p>Catalyst Forge is the development platform that powers the software lifecycle of all applications and services within Project Catalyst. It ships as a suite of configurations, services, and command-line utilities that, together, accelerate development of our projects. It is especially inspired by the principles and philosophies of platform engineering.</p> <p>Note</p> <p>If you're an external contributor to Project Catalyst, we greatly value your work! Being familiar with Catalyst Forge is a great way to ensure your contributions are merged as quickly as possible. However, note that some of the features provided by Catalyst Forge will only work for core developers within the Project Catalyst team. This documentation will denots these features ahead of time.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>If you're new to Catalyst Forge, the quickest way to get familiar with what it offers is through the getting started tutorial.</p>"},{"location":"introduction/getting_started/","title":"Getting Started","text":"<p>In this tutorial, we will create a sample project that will be automatically validated, built, and published by Catalyst Forge. During this process, we will encounter the various tools and configurations that power Catalyst Forge. By the end of this tutorial, you will be equipped to begin developing your own projects.</p> <p>We will be building a trivial program in the Python language in order to facilitate learning. Python was chosen due to its simplicity and more well-known nature. Understanding the Python language is not required, and more adventerous learners may choose to substitute the code with their language of choice. Catalyst Forge is language agnostic; all that is required is knowing how to build and validate your language of choice.</p>"},{"location":"introduction/getting_started/#pre-requisites","title":"Pre-requisites","text":"<p>Note</p> <p>External contributors will only be able to partially complete this tutorial. This is due to the fact that permissions on most repositories (including the playground) do not allow external contributors to arbitrarily merge code. If you're an external contributor, feel free to follow the tutorial up to the point where merging is required.</p> <p>Prior to starting this tutorial, please ensure you have the following available on your machine:</p> <ol> <li>The latest version of the forge CLI</li> <li>A recent version of Earthly installed and configured</li> <li>(Optional) The <code>uv</code> Python tool</li> </ol> <p>If you would like to use a differnet Python package manager, or just use vanilla tooling, then you will need to adapt some of the below steps for those specific tools. This tutorial is focused on introducing Catalyst Forge and <code>uv</code> is only being used to simplify the tutorial.</p>"},{"location":"introduction/getting_started/#project-setup","title":"Project Setup","text":"<p>To begin, clone the catalyst-forge-playground locally. Make a new folder under the <code>users</code> directory in the root of the repository using your GitHub username. Inside of your newly created folder, initialize a new Python project:</p> <pre><code>uv init\n</code></pre> <p>From the same folder, add the <code>click</code> package by running:</p> <pre><code>uv add click\n</code></pre> <p>Finally, add <code>black</code>, <code>ruff</code>, and <code>pytest</code>:</p> <pre><code>uv add black pytest ruff --optional dev\n</code></pre> <p>Since we are creating a CLI, we will need to modify the structure of the project:</p> <pre><code>$ mkdir -p src/hello\n$ mv hello.py src/hello/hello.py\n$ touch src/hello/__init__.py\n</code></pre> <p>And then modify our <code>pyproject.toml</code> to include the following:</p> <pre><code>[project.scripts]\nhello = \"hello.hello:cli\"\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.targets.wheel]\npackages = [\"src/hello\"]\n</code></pre>"},{"location":"introduction/getting_started/#create-cli","title":"Create CLI","text":"<p>Modify the <code>src/hello/hello.py</code> file with the following code:</p> <pre><code>import click\n\ndef hello(name: str = \"World\") -&gt; str:\n    return f\"Hello, {name}!\"\n\n@click.command()\n@click.argument('name', required=False, default=\"World\")\ndef cli(name):\n    click.echo(hello(name))\n\nif __name__ == '__main__':\n    cli()\n</code></pre> <p>Now add a simple test in <code>tests/hello_test.py</code>:</p> <pre><code>from hello.hello import hello\n\n\ndef test_hello():\n    assert hello(\"Alice\") == \"Hello, Alice!\"\n    assert hello() == \"Hello, World!\"\n</code></pre> <p>Validate everything works:</p> <pre><code>$ uv run hello test\nHello, test!\n\n$ uv run pytest .\n=========================================================== test session starts ===========================================================\nplatform linux -- Python 3.12.5, pytest-8.3.3, pluggy-1.5.0\nrootdir: /var/home/josh/work/catalyst-forge-playground/users/jmgilman\nconfigfile: pyproject.toml\ncollected 2 items\n\nhello_test.py ..                                                                                                                    [100%]\n\n============================================================ 2 passed in 0.01s ============================================================\n</code></pre>"},{"location":"introduction/getting_started/#creating-an-earthfile","title":"Creating an Earthfile","text":"<p>Catalyst Forge uses Earthly underneath the hood for building applications. To begin, we will create a simple <code>Earthfile</code> in our folder that will validate our code for us:</p> <pre><code>VERSION 0.8\n\nuv:\n    FROM ghcr.io/astral-sh/uv:0.4.12\n\n    SAVE ARTIFACT /uv uv\n\ndeps:\n    FROM python:3.12-slim-bookworm\n\n    ENV UV_COMPILE_BYTECODE=0\n\n    WORKDIR /work\n\n    COPY +uv/uv /usr/local/bin/uv\n    COPY pyproject.toml uv.lock README.md .\n\n    RUN uv sync --frozen --no-install-project\n\nsrc:\n    FROM +deps\n\n    COPY --dir src README.md .\n</code></pre> <p>Most of the above targets are there to install <code>uv</code> in the container and initialize the container environment. The <code>src</code> target will contain all of the code and dependencies we need to run our application.</p>"},{"location":"introduction/getting_started/#checking","title":"Checking","text":"<p>Add the following target to the <code>Earthfile</code>:</p> <pre><code>check:\n    FROM +src\n\n    RUN uv sync --frozen --no-install-project --extra dev\n\n    RUN uv run black --check .\n    RUN uv run ruff check .\n</code></pre> <p>The <code>check</code> target is automatically run for us as the first step in the CI pipeline. It's intended to have a short execution time. In the above case, we are validating formatting and performing linting, both which tend to execute relatively quickly.</p> <p>Validate that the <code>check</code> target passes with no issues:</p> <pre><code>forge run +check\n</code></pre> <p>When testing a target locally, it's recommended you use the <code>forge</code> CLI over the native <code>earthly</code> CLI. During CI runs, the <code>forge</code> CLI is used to execute all Earthly targets. This ensures more consistency between running the target locally and when running it in CI, as the CLI adds several additional features that are not natively present in Earthly.</p>"},{"location":"introduction/getting_started/#testing","title":"Testing","text":"<p>For running our tests, we will add a <code>test</code> target to the <code>Earthfile</code>:</p> <pre><code>test:\n    FROM +src\n\n    COPY --dir tests .\n\n    RUN uv sync --frozen --extra dev\n    RUN uv run pytest .\n</code></pre> <p>Like the <code>check</code> target, the <code>test</code> target is also called by CI. It's intended to be used for running all tests in a project (including unit and integration tests). Since we're using <code>pytest</code>, we only need to call it for our simple unit test to run.</p>"},{"location":"introduction/getting_started/#building","title":"Building","text":"<p>We will build our CLI as a Python wheel to make distributing/publishing it easier. To do this, add a new <code>build</code> target to the <code>Earthfile</code>:</p> <pre><code>build:\n    FROM +src\n\n    RUN uv build --wheel\n\n    SAVE ARTIFACT dist dist\n</code></pre> <p>Like the previous targets, the <code>build</code> target is also called by CI. This ensures that the <code>build</code> can run successfully before calling additional targets that might rely on it (it also caches it). In the above case, <code>uv</code> will build our wheel and place it in the <code>dist/</code> folder for us. We save the entire folder as an artifact for later targets to use.</p>"},{"location":"introduction/getting_started/#publishing","title":"Publishing","text":"<p>We will now create the container that will be responsible for running our CLI. To do this, add a new <code>publish</code> target to the <code>Earthfile</code>:</p> <pre><code>publish:\n    FROM python:3.12-slim\n\n    ARG container=hello\n    ARG tag=latest\n\n    WORKDIR /app\n\n    COPY +build/dist dist\n\n    RUN pip install dist/*.whl\n\n    SAVE IMAGE ${container}:${tag}\n</code></pre> <p>The target copies the wheel from the <code>build</code> target and then globally installs it into the container. Since we've configured a script entry in our <code>pyproject.toml</code>, the CLI can be run by executing <code>hello</code>.</p> <p>The CI will automatically pass in the <code>container</code> and <code>tag</code> arguments in order to set the container name. These arguments are not optional and must be included in all <code>publish</code> targets.</p> <p>Let's now build our image and make sure it works:</p> <pre><code>$ forge run +publish\n$ docker run hello:latest test\nHello, test!\n</code></pre> <p>Like the other targets, the CI system will automatically run the <code>publish</code> target in the pipeline. Unlike the other targets, the <code>publish</code> target is special in that the CI system expects it to produce a container image. During certain contexts, the CI system will automatically tag and publish the image for us.</p>"},{"location":"introduction/getting_started/#releasing","title":"Releasing","text":"<p>As a last step, we will create a <code>release</code> target that will expose our wheel from the <code>build</code> target:</p> <pre><code>release:\n    FROM scratch\n\n    COPY +build/dist dist\n\n    SAVE ARTIFACT dist/* hello.whl\n</code></pre> <p>Like the <code>publish</code> target, the <code>release</code> target is special and the CI system expects it to produce at least one artifact. During certain contexts, the CI system will publish a release using any artifacts produced by the target. You can validate this behavior by running the following:</p> <pre><code>$ forge run --artifact out +release\n$ unzip -l out/linux/amd64/dist\nArchive:  out/linux/amd64/dist\n  Length      Date    Time    Name\n---------  ---------- -----   ----\n        0  02-02-2020 00:00   hello/__init__.py\n      241  02-02-2020 00:00   hello/hello.py\n      288  02-02-2020 00:00   hello-0.1.0.dist-info/METADATA\n       87  02-02-2020 00:00   hello-0.1.0.dist-info/WHEEL\n       42  02-02-2020 00:00   hello-0.1.0.dist-info/entry_points.txt\n      433  02-02-2020 00:00   hello-0.1.0.dist-info/RECORD\n---------                     -------\n     1091                     6 files\n</code></pre> <p>Depending on your local architecture, the path to the artifact may be different.</p>"},{"location":"introduction/getting_started/#adding-a-blueprint","title":"Adding a Blueprint","text":"<p>Catalyst Forge uses blueprint files in order to both identify projects within a repository as well as configure them. Add a new file in the root of the project folder called <code>blueprint.cue</code> with the following contents:</p> <pre><code>version: \"1.0.0\"\nproject: {\n    name: \"hello-jmgilman\"\n}\n</code></pre> <p>A blueprint file in a directory signifies that it is a project within a repository. Many of the Catalyst automation systems interact with projects inside of a repository and use the existence of this file to distinguish them. For example, without this file, our <code>Earthfile</code> would be ignored by the CI system and none of our targets would run in the pipeline.</p> <p>The only required field in a blueprint file is the project name (shown as <code>hello-jmgilman</code> above). This name should be unique across all repositories and is used to distinguish the project in several area (i.e. the container name). There are many more useful fields exposed in a blueprint file that can be explored later in the documentation.</p>"},{"location":"introduction/getting_started/#testing-locally","title":"Testing Locally","text":"<p>Prior to pushing our changes in a PR, let's test the full CI pipeline locally:</p> <pre><code>forge ci --local .\n</code></pre> <p>The <code>.</code> parameter is important as it will scope the CI run to only our project. If everything is working correctly, all targets should be run in the correct order and pass with a green checkmark. We've now built our sample application, validated and tested it, and even have potential publish and release artifacts for it.</p>"},{"location":"introduction/getting_started/#submiting-to-ci","title":"Submiting to CI","text":"<p>Note</p> <p>The CI system in the playground is not connected to any remote build servers for security reasons. As a result, builds will not be cached and will start from scratch each time.</p> <p>Now that we've validated everything locally, we will push our changes to a new branch and open up a PR. After opening the PR, you should see a new GitHub Action workflow start.</p> <p></p> <p>Examining the workflow, you can see that it follows the same steps as was shown in our local run. The only difference is that all projects within the repository are being run in parallel. If any of these projects fail, the entire pipeline will fail. This is intentional, as all projects should be successfully building before merging a PR to the default branch.</p>"},{"location":"introduction/getting_started/#releasing-and-publishing","title":"Releasing and Publishing","text":"<p>Note</p> <p>The steps below require permissions to merge and tag the playground repository. If you don't have these permissions, you may still read on for educational purposes. Alternatively, you may seek someone out with the necesary permissions to help you (feel free to open an issue!).</p> <p>Once the PR has successfully passed CI, proceed with merging it to the default branch (please use squash merges). After the merge, a new GitHub Workflow will run for this particular commit. Allow the workflow to run to completion before proceeding.</p> <p>Once the workflow has completed, you'll notice a new package created for the GitHub Container Registry. The package will have the same name as the name as defined in <code>project.name</code> and will, by default, have a tag created that matches the commit hash of the merge commit. Whenever a new PR is merged into the default branch, all projects with a publish target will have their respective container images pushed to configured registries using the commit hash as the tag.</p> <p>For the final step, we will tag the repository with an application specific tag:</p> <pre><code>git tag -a \"examples/&lt;username&gt;/v1.0.0\" -m \"My first version\"\ngit push origin master\n</code></pre> <p>This creates a new tag using the traditional \"mono repo\" style tag. The prefix is the path to the project in the repository and the suffix is the semantic version for that project. After creating and pushing this tag, a new workflow is created and the CI pipeline runs again. Allow the new workflow to run to completion before proceeding.</p> <p>Once the workflow is completed, you'll notice that a new release is created on GitHub with the name set to our git tag. The release will contain a single artifact which is the Python wheel created by our <code>release</code> target. Notice that no other projects had a release added. This is the default behavior: only projects which \"match\" the mono repo tag will create a new release and upload assets. All other projects will skip this step.</p>"},{"location":"introduction/getting_started/#conclusion","title":"Conclusion","text":"<p>That's it for this getting started tutorial. You now understand the fundamentals of creating and managing projects using Catalyst Forge!</p>"},{"location":"introduction/installation/","title":"Installation","text":""},{"location":"introduction/installation/#pre-requisites","title":"Pre-requisites","text":"<p>Catalyst Forge heavily relies on Earthly underneath the hood. All CI execution steps rely on calling Earthly targets defined in <code>Earthfile</code>'s. It's recommended you install Earthly on your local system using their installation instructions.</p>"},{"location":"introduction/installation/#forge-cli","title":"Forge CLI","text":"<p>The <code>forge</code> CLI is the primary interface in which you, as a developer, will interact with Catalyst Forge. The CLI is written in Go and is distributed as a single binary that is available for multiple platforms.</p> <p>To get started, head over to the releases and download the archive that is compatible with your local system. Once downloaded, extract the archive to find a single <code>forge</code> binary. It's recommended you place the binary in a location on your local system that is accessible by <code>$PATH</code>.</p>"},{"location":"introduction/installation/#validate","title":"Validate","text":"<p>To validate that forge is installed correctly, you can run:</p> <pre><code>$ forge version\nforge version 0.1.0 linux/amd64\nconfig schema version 1.0.0\n</code></pre>"}]}