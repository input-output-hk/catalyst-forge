{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Catalyst Forge","text":"<p>Catalyst Forge is the development platform that powers the software lifecycle of all applications and services within Project Catalyst. It ships as a suite of configurations, services, and command-line utilities that, together, accelerate development of our projects. It is especially inspired by the principles and philosophies of platform engineering.</p> <p>Note</p> <p>If you're an external contributor to Project Catalyst, we greatly value your work! Being familiar with Catalyst Forge is a great way to ensure your contributions are merged as quickly as possible. However, note that some of the features provided by Catalyst Forge will only work for core developers within the Project Catalyst team. This documentation will denots these features ahead of time.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>If you're new to Catalyst Forge, the quickest way to get familiar with what it offers is through the getting started tutorial.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#pre-requisites","title":"Pre-requisites","text":"<p>Catalyst Forge heavily relies on Earthly underneath the hood. All CI execution steps rely on calling Earthly targets defined in <code>Earthfile</code>'s. It's recommended you install Earthly on your local system using their installation instructions.</p>"},{"location":"installation/#forge-cli","title":"Forge CLI","text":"<p>The <code>forge</code> CLI is the primary interface in which you, as a developer, will interact with Catalyst Forge. The CLI is written in Go and is distributed as a single binary that is available for multiple platforms.</p> <p>To get started, head over to the releases and download the archive that is compatible with your local system. Once downloaded, extract the archive to find a single <code>forge</code> binary. It's recommended you place the binary in a location on your local system that is accessible by <code>$PATH</code>.</p>"},{"location":"installation/#validate","title":"Validate","text":"<p>To validate that forge is installed correctly, you can run:</p> <pre><code>$ forge version\nforge version 0.1.0 linux/amd64\nconfig schema version 1.0.0\n</code></pre>"},{"location":"concepts/blueprints/","title":"Blueprints","text":"<p>A blueprint contains all of the configuration data necessary for Catalyst Forge to process a project. The configuration is defined in a blueprint file (<code>blueprint.cue</code>) that exists in the root directory of a project. Blueprints are not optional and must exist for every project.</p>"},{"location":"concepts/blueprints/#language","title":"Language","text":"<p>Blueprints are written in the CUE language (denoted by the <code>.cue</code> extension). When a project is loaded, the Forge runtime will automatically load and parse the associated blueprint file using CUE. For more information on CUE, please refer to the CUE documentation.</p>"},{"location":"concepts/blueprints/#schema","title":"Schema","text":"<p>The schema for blueprint files is defined in both Go and CUE. The latest schema can be found here. Alternatively, the Go code responsible for generating the schema can be explored here.</p> <p>Note that the schema is enforced at runtime. Improperly named fields, fields not specified in the schema, or incorrect types on fields will all cause runtime errors in all Forge systems.</p>"},{"location":"concepts/blueprints/#versioning","title":"Versioning","text":"<p>Note</p> <p>Blueprints are versioned using semantic versioning. However, only the major and minor sections are used. The patch section is ignored.</p> <p>Every blueprint must specify a <code>version</code> field at the top-level of the file. This informs Forge what version of the schema is being used. The version is hard-coded in the source code and is bumped whenever a change to the schema is made.</p> <p>All systems within the Forge ecosystem have a dependency on this schema. For exampe, the version embedded into the Forge CLI can be found by running:</p> <pre><code>$ forge version\nforge version v0.1.0 linux/amd64\nconfig schema version 1.0.0\n</code></pre> <p>When a Forge system is processing a blueprint file, it first checks the version specified in the file against the version it was compiled with. It then uses the following rules to determine if it is safe to proceed:</p> <ul> <li>The major versions match</li> <li>The minor version of the embedded schema is greater than or equal to the minor verion specified in the blueprint</li> </ul> <p>In the case where the major versions mismatch, the tool will refuse to parse the blueprint file. In the case where the minor version is less than the one specified in the blueprint, a warning is emitted but the blueprint file will still be parsed.</p>"},{"location":"concepts/ci/","title":"CI","text":"<p>One of the primary components of Catalyst Forge is the integrated CI system. The standardization of the git repository structure allows for automatic discovery and execution of distributed CI code. The Forge CI system takes advantage of this and dynamically builds a CI pipeline that changes as the repository changes. Adding a new project (along with the associated CI code) is all it takes to integrate with the system.</p>"},{"location":"concepts/ci/#architecture","title":"Architecture","text":""},{"location":"concepts/ci/#discovery","title":"Discovery","text":"<p>The CI system is built on a simple discovery mechanism. When the system starts, it recursively scans from the root of the repository looking for projects. For each project found, it looks for and parses an associated <code>Earthfile</code> and collects all of the defined targets. It then filters and orders these targets into discrete target groups using a list of reguar expressions predefined by Forge. The name and dependency order of these groups is hardcoded and does not often change.</p> <p>Each of these target groups can be considered phases in the overall CI pipeline. Each phase consists of the associated targets and each phase occur in dependency order. The name and order of these phases is hardcoded and can be found here.</p>"},{"location":"concepts/ci/#execution","title":"Execution","text":"<p>For each phase, the CI system spawns a series of parallel jobs that executes each individual target. Each target execution is given its own unique job in GitHub Actions to allow easy identification of failing targets as well as providing an isolated log stream for a single target. If any target in the group fails, the entire group is considered to be failed, and CI execution stops.</p> <p>Hint</p> <p>This means that any failing project in the repository will stop CI execution. If a code change in one project causes a dependent project to fail, it's expected that the dependent project is fixed. This promotes a \"full ownership\" philosophy where developers are responsible for ensuring their changes keep CI passing.</p> <p>Projects are not required to define targets for each phase. In some cases, a phase may only contain a subset of projects. If a phase ends up with zero targets, the entire job is skipped. This allows repositories to define a small subset of targets initially and grow as project complexity increases.</p> <p>Some target executions are limited to running the associated Earthly target and then immediately finishing. Other targets have additional logic that is executed after the target finishes running. For example, the <code>publish</code> target will automatically publish container images generated by the target to any configured registries. For more information on supported targets, please see the reference documentation.</p>"},{"location":"concepts/ci/#extending","title":"Extending","text":"<p>Due to the underlying discovery mechanism, creating new jobs within the CI system is as simple as adding targets to the <code>Earthfile</code> of a project. As long as it meets the criteria of a supported target (see the reference documentation), the system will automatically discover and execute the target in the appropriate phase.</p> <p>Using the architecture diagram above as an example, a <code>package</code> target can be added to the <code>bar</code> project with one addition to the <code>Earthfile</code>:</p> <pre><code>package:\n    FROM ubuntu:latest\n\n    RUN ....\n</code></pre> <p>On the next invocation of the CI system, the newly added <code>package</code> target will be discovered and executed during the package phase.</p>"},{"location":"concepts/projects/","title":"Projects","text":"<p>The primary component of Catalyst Forge is the project. Forge is designed to interact with monorepos, where each repository contains one or more projects. A project can be classified as a discrete deliverable within a repository: it has own its dedicated process for validating, building, testing, and potentially deploying.</p>"},{"location":"concepts/projects/#organizing-projects","title":"Organizing Projects","text":"<p>Tip</p> <p>While there's no hierarchical order enforced by Forge, it's against best practices to have projects live at the root of a repository. The only exception to this case is where the repository only has a single deliverable.</p> <p>Catalyst Forge does not enforce projects live in any particular folder within the repository. Developers are encouraged to organize the repository in whatever way makes sense for them. The discovery mechanisms used by Forge will ensure that projects are found no matter where they live.</p> <p>In some cases, projects may have dependencies on each other. For example, one project may have a dependency on one or more projects that provide language libraries. Whether or not these are treated as separate projects is up to developers. If a library is used by more than one project, or is consumed externally, it's recommended to treat it as a separate project.</p>"},{"location":"concepts/projects/#project-components","title":"Project Components","text":"<p>Forge discovers projects within a repository using a specific set of rules. Namely, a valid project is any folder within the repository that contains a blueprint (<code>blueprint.cue</code>). This is the only requirement for forge to classify that directory as a project. While a project may consist of one or more other files or directories, the blueprint should always exist at the root of the project folder.</p> <p>Optionally, a project may also contain an <code>Earthfile</code> that contains definitions for the common targets used by the CI system. The CI system automatically checks for the existence of this file after it discovers a project. However, it's important to recognize the existence of an <code>Earthfile</code> does not define a project according to Forge.</p>"},{"location":"concepts/projects/#project-configuration","title":"Project Configuration","text":"<p>A project's configuration is defined within the blueprint file contained at the root of the project folder. How this file is configured is outside the scope of this document. See the blueprints section for more details.</p>"},{"location":"reference/targets/","title":"Targets","text":"<p>The Forge CI system automatically scans and executes a preset number of Earthly targets. This section describes each of those targets including any special logic associated with it. Each target includes a brief example using the Go programming language. This is only done for simplicity as each target can be used to support multiple languages/paradigms.</p>"},{"location":"reference/targets/#check","title":"Check","text":"<p>The <code>check</code> target is used for performing static analysis on a project's code. This includes operations like validating formatting, linting, or scanning for vulnerable code. It can also include running analyzers on supporting artifacts of a project, like spellchecking a project's README.</p> <p>The goal of the <code>check</code> target is to provide quick feedback on the validity of a project. This is why it is the first target that is run in the CI pipeline. As such, the speed of the <code>check</code> target invocation should be prioritized above all else. If possible, it should avoid building the underlying project or doing any computationally expensive tasks. The faster the target runs, the quicker developers can get feedback on \"easy\" fixes within the codebase.</p>"},{"location":"reference/targets/#example","title":"Example","text":"<pre><code>check:\n    # Assume we've copied the source code in a previous target\n    FROM +src\n\n    # Validate that the code is formatted correctly\n    RUN gofmt -l . | grep . &amp;&amp; exit 1 || exit 0\n\n    # Run a simple lint on the code\n    RUN go vet ./...\n</code></pre>"},{"location":"reference/targets/#build","title":"Build","text":"<p>The <code>build</code> target is used for building the artifacts of a project. The concept of building is unique to a project and can include anything ranging from compiling a binary, to archiving interpreted code into a portable artifact, or generating static assets for a web frontend. In some cases, like with library code, making use of this target does not make sense and it should be skipped.</p> <p>The primary purpose of the <code>build</code> target is to optimize caching. By forcing the project to build during this target, all future targets which rely on the <code>build</code> target will be optimized via caching. For example, the <code>test</code> target often relies on the project being built prior to running tests. Since the <code>test</code> target occurs after the <code>build</code> target it will immediately benefit from the build being cached.</p> <p>The <code>build</code> target should prefer to always produce an artifact, where possible. Meaning, the target should use <code>SAVE ARTIFACT</code> on the resulting build at the end of execution. Dependent projects will often pull the artifact directly from this target.</p>"},{"location":"reference/targets/#example_1","title":"Example","text":"<pre><code>build:\n    # Assume we've copied the source code in a previous target\n    FROM +src\n\n    # Compile our binary\n    RUN go build -o bin/program cmd/main.go\n\n    # Save the resulting binary as an artifact\n    SAVE ARTIFACT bin/program program\n</code></pre>"},{"location":"reference/targets/#package","title":"Package","text":"<p>The <code>package</code> target is used for packaging dependent projects together. In some cases, a larger piece of software may be broken up into multiple projects inside of a repository. The <code>package</code> target should be used to create the final artifact for the projects.</p> <p>For example, there may be one project reponsible for building static assets and another project building the server binary that depends on those assets. The server binary should utilize the <code>package</code> target to pull in the static assets and package them with the binary into a final artifact.</p>"},{"location":"reference/targets/#example_2","title":"Example","text":"<pre><code>package:\n    FROM scratch\n\n    RUN mkdir dist\n    COPY +build/program dist/program\n    COPY ../assets+build dist/assets\n\n    SAVE ARTIFACT dist\n</code></pre>"},{"location":"reference/targets/#test","title":"Test","text":"<p>The <code>test</code> target is used for running both unit and integration tests. The target is often run in privileged mode to make use of docker-in-docker for running complex integration tests. This target is intentionally run after both the <code>build</code> and <code>package</code> targets in order to allow using the resulting artifacts and maximize caching.</p> <p>The <code>test</code> target is the final validation step in the CI pipeline. The targets that follow assume that if the <code>test</code> target passes, the project is ready to be released, published, or deployed. It is therefore recommended that all necessary validation logic is included between the <code>check</code> and <code>test</code> targets.</p>"},{"location":"reference/targets/#example_3","title":"Example","text":"<pre><code>test:\n    # Assume we've copied the source code in a previous target\n    FROM +src\n\n    # Run our unit tests\n    RUN go test ./...\n</code></pre>"},{"location":"reference/targets/#publish","title":"Publish","text":"<p>The <code>publish</code> target is used to generate the container for a project. It is an error to define the target and not generate an image and the CI system expects only a single image. The contents of the image are project-specific, but it's often the artifacts generated by the project in a deployable form. For example, an API server may copy the server binary into a vanilla image and automatically set it as the default entrypoint.</p> <p>The <code>publish</code> target must expose two arguments: <code>container</code> and <code>image</code>. These arguments are given values at runtime by the CI system. The arguments should be used when saving the final image name and tag (see the example below). Omitting these arguments will cause the CI system to fail to find the saved image.</p> <p>After the <code>publish</code> target is ran for a project, the CI system automatically publishes the resulting container image to all configured container registries. In the case where multiple platforms are specified for a project, the CI system will first upload each platform-specific image to all registries and then create a single multi-platform manifest that points to the images. Each image is tagged based on the tagging strategy defined in the blueprint global settings.</p>"},{"location":"reference/targets/#example_4","title":"Example","text":"<pre><code>publish:\n    FROM debian:bookworm-slim\n\n    ARG container\n    ARG tag\n\n    COPY +build/program program\n\n    ENTRYPOINT [\"/program\"]\n    SAVE IMAGE ${container}:${tag}\n</code></pre>"},{"location":"reference/targets/#release","title":"Release","text":"<p>The <code>release</code> target is used for creating GitHub Releases for a project. The target must produce at least one artifact. The contents of the artifact are specific to the project. For example, the artifact may be the binary file for a compiled project or a directory of assets for a frontend project.</p> <p>After the <code>release</code> target is ran for a project, the CI system will check if there's a git tag present in the current run context. If a tag is found it will be compared against the current project to ensure it matches. In the case of a match, the CI system will then create a new GitHub release using the git tag as the name. Finally, the CI system will archive and compress the artifact produced by the <code>release</code> target and attach it as an asset to the release.</p> <p>In the case where multiple platforms are specified for a project, the system will archive and compress each artifact separately. The generated archive name will have the associated platform added as a suffix in the file name. All archives will then be attached to the generated release as assets.</p>"},{"location":"reference/targets/#example_5","title":"Example","text":"<pre><code>release:\n    FROM scratch\n\n    COPY +build/program program\n\n    SAVE ARTIFACT program\n</code></pre>"},{"location":"reference/targets/#docs","title":"Docs","text":"<p>Warning</p> <p>Only one <code>docs</code> target should be specified per repository. Defining more than one of these targets leads to undefined behavior. In the case where documentation is contained within a project, it should be copied from that project and included in the final artifact created by the target.</p> <p>The <code>docs</code> target is a special target used for uploading documentation to GitHub Pages. The target should produce a single directory that contains all of the static assets for the documentation. The CI system will automatically publish the generated documentation to the default <code>gh-pages</code> branch.</p> <p>In the case where the target is running outside of the default branch (i.e., <code>main</code> or <code>master</code>) the generated documentation will be published to a subfolder within the <code>gh-pages</code> branch. The subfolder will be named after the branch name. This allows previewing documentation generated by a branch by appending the branch name to the URL configured within GitHub Pages.</p>"},{"location":"reference/targets/#example_6","title":"Example","text":"<pre><code>docs:\n    FROM +build\n\n    SAVE ARTIFACT dist\n</code></pre>"},{"location":"tutorials/getting_started/","title":"Getting Started","text":"<p>In this tutorial, we will create a sample project that will be automatically validated, built, and published by Catalyst Forge. During this process, we will encounter the various tools and configurations that power Catalyst Forge. By the end of this tutorial, you will be equipped to begin developing your own projects.</p> <p>We will be building a trivial program in the Python language in order to facilitate learning. Python was chosen due to its simplicity and more well-known nature. Understanding the Python language is not required, and more adventerous learners may choose to substitute the code with their language of choice. Catalyst Forge is language agnostic; all that is required is knowing how to build and validate your language of choice.</p>"},{"location":"tutorials/getting_started/#pre-requisites","title":"Pre-requisites","text":"<p>Note</p> <p>External contributors will only be able to partially complete this tutorial. This is due to the fact that permissions on most repositories (including the playground) do not allow external contributors to arbitrarily merge code. If you're an external contributor, feel free to follow the tutorial up to the point where merging is required.</p> <p>Prior to starting this tutorial, please ensure you have the following available on your machine:</p> <ol> <li>The latest version of the forge CLI</li> <li>A recent version of Earthly installed and configured</li> <li>(Optional) The <code>uv</code> Python tool</li> </ol> <p>If you would like to use a differnet Python package manager, or just use vanilla tooling, then you will need to adapt some of the below steps for those specific tools. This tutorial is focused on introducing Catalyst Forge and <code>uv</code> is only being used to simplify the tutorial.</p>"},{"location":"tutorials/getting_started/#project-setup","title":"Project Setup","text":"<p>To begin, clone the catalyst-forge-playground locally. Make a new folder under the <code>users</code> directory in the root of the repository using your GitHub username. Inside of your newly created folder, initialize a new Python project:</p> <pre><code>uv init\n</code></pre> <p>From the same folder, add the <code>click</code> package by running:</p> <pre><code>uv add click\n</code></pre> <p>Finally, add <code>black</code>, <code>ruff</code>, and <code>pytest</code>:</p> <pre><code>uv add black pytest ruff --optional dev\n</code></pre> <p>Since we are creating a CLI, we will need to modify the structure of the project:</p> <pre><code>$ mkdir -p src/hello\n$ mv hello.py src/hello/hello.py\n$ touch src/hello/__init__.py\n</code></pre> <p>And then modify our <code>pyproject.toml</code> to include the following:</p> <pre><code>[project.scripts]\nhello = \"hello.hello:cli\"\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.targets.wheel]\npackages = [\"src/hello\"]\n</code></pre>"},{"location":"tutorials/getting_started/#create-cli","title":"Create CLI","text":"<p>Modify the <code>src/hello/hello.py</code> file with the following code:</p> <pre><code>import click\n\ndef hello(name: str = \"World\") -&gt; str:\n    return f\"Hello, {name}!\"\n\n@click.command()\n@click.argument('name', required=False, default=\"World\")\ndef cli(name):\n    click.echo(hello(name))\n\nif __name__ == '__main__':\n    cli()\n</code></pre> <p>Now add a simple test in <code>tests/hello_test.py</code>:</p> <pre><code>from hello.hello import hello\n\n\ndef test_hello():\n    assert hello(\"Alice\") == \"Hello, Alice!\"\n    assert hello() == \"Hello, World!\"\n</code></pre> <p>Validate everything works:</p> <pre><code>$ uv run hello test\nHello, test!\n\n$ uv run pytest .\n=========================================================== test session starts ===========================================================\nplatform linux -- Python 3.12.5, pytest-8.3.3, pluggy-1.5.0\nrootdir: /var/home/josh/work/catalyst-forge-playground/users/jmgilman\nconfigfile: pyproject.toml\ncollected 2 items\n\nhello_test.py ..                                                                                                                    [100%]\n\n============================================================ 2 passed in 0.01s ============================================================\n</code></pre>"},{"location":"tutorials/getting_started/#creating-an-earthfile","title":"Creating an Earthfile","text":"<p>Catalyst Forge uses Earthly underneath the hood for building applications. To begin, we will create a simple <code>Earthfile</code> in our folder that will validate our code for us:</p> <pre><code>VERSION 0.8\n\nuv:\n    FROM ghcr.io/astral-sh/uv:0.4.12\n\n    SAVE ARTIFACT /uv uv\n\ndeps:\n    FROM python:3.12-slim-bookworm\n\n    ENV UV_COMPILE_BYTECODE=0\n\n    WORKDIR /work\n\n    COPY +uv/uv /usr/local/bin/uv\n    COPY pyproject.toml uv.lock README.md .\n\n    RUN uv sync --frozen --no-install-project\n\nsrc:\n    FROM +deps\n\n    COPY --dir src README.md .\n</code></pre> <p>Most of the above targets are there to install <code>uv</code> in the container and initialize the container environment. The <code>src</code> target will contain all of the code and dependencies we need to run our application.</p>"},{"location":"tutorials/getting_started/#checking","title":"Checking","text":"<p>Add the following target to the <code>Earthfile</code>:</p> <pre><code>check:\n    FROM +src\n\n    RUN uv sync --frozen --no-install-project --extra dev\n\n    RUN uv run black --check .\n    RUN uv run ruff check .\n</code></pre> <p>The <code>check</code> target is automatically run for us as the first step in the CI pipeline. It's intended to have a short execution time. In the above case, we are validating formatting and performing linting, both which tend to execute relatively quickly.</p> <p>Validate that the <code>check</code> target passes with no issues:</p> <pre><code>forge run +check\n</code></pre> <p>When testing a target locally, it's recommended you use the <code>forge</code> CLI over the native <code>earthly</code> CLI. During CI runs, the <code>forge</code> CLI is used to execute all Earthly targets. This ensures more consistency between running the target locally and when running it in CI, as the CLI adds several additional features that are not natively present in Earthly.</p>"},{"location":"tutorials/getting_started/#testing","title":"Testing","text":"<p>For running our tests, we will add a <code>test</code> target to the <code>Earthfile</code>:</p> <pre><code>test:\n    FROM +src\n\n    COPY --dir tests .\n\n    RUN uv sync --frozen --extra dev\n    RUN uv run pytest .\n</code></pre> <p>Like the <code>check</code> target, the <code>test</code> target is also called by CI. It's intended to be used for running all tests in a project (including unit and integration tests). Since we're using <code>pytest</code>, we only need to call it for our simple unit test to run.</p>"},{"location":"tutorials/getting_started/#building","title":"Building","text":"<p>We will build our CLI as a Python wheel to make distributing/publishing it easier. To do this, add a new <code>build</code> target to the <code>Earthfile</code>:</p> <pre><code>build:\n    FROM +src\n\n    RUN uv build --wheel\n\n    SAVE ARTIFACT dist dist\n</code></pre> <p>Like the previous targets, the <code>build</code> target is also called by CI. This ensures that the <code>build</code> can run successfully before calling additional targets that might rely on it (it also caches it). In the above case, <code>uv</code> will build our wheel and place it in the <code>dist/</code> folder for us. We save the entire folder as an artifact for later targets to use.</p>"},{"location":"tutorials/getting_started/#publishing","title":"Publishing","text":"<p>We will now create the container that will be responsible for running our CLI. To do this, add a new <code>publish</code> target to the <code>Earthfile</code>:</p> <pre><code>publish:\n    FROM python:3.12-slim\n\n    ARG container=hello\n    ARG tag=latest\n\n    WORKDIR /app\n\n    COPY +build/dist dist\n\n    RUN pip install dist/*.whl\n\n    SAVE IMAGE ${container}:${tag}\n</code></pre> <p>The target copies the wheel from the <code>build</code> target and then globally installs it into the container. Since we've configured a script entry in our <code>pyproject.toml</code>, the CLI can be run by executing <code>hello</code>.</p> <p>The CI will automatically pass in the <code>container</code> and <code>tag</code> arguments in order to set the container name. These arguments are not optional and must be included in all <code>publish</code> targets.</p> <p>Let's now build our image and make sure it works:</p> <pre><code>$ forge run +publish\n$ docker run hello:latest test\nHello, test!\n</code></pre> <p>Like the other targets, the CI system will automatically run the <code>publish</code> target in the pipeline. Unlike the other targets, the <code>publish</code> target is special in that the CI system expects it to produce a container image. During certain contexts, the CI system will automatically tag and publish the image for us.</p>"},{"location":"tutorials/getting_started/#releasing","title":"Releasing","text":"<p>As a last step, we will create a <code>release</code> target that will expose our wheel from the <code>build</code> target:</p> <pre><code>release:\n    FROM scratch\n\n    COPY +build/dist dist\n\n    SAVE ARTIFACT dist/* hello.whl\n</code></pre> <p>Like the <code>publish</code> target, the <code>release</code> target is special and the CI system expects it to produce at least one artifact. During certain contexts, the CI system will publish a release using any artifacts produced by the target. You can validate this behavior by running the following:</p> <pre><code>$ forge run --artifact out +release\n$ unzip -l out/linux/amd64/dist\nArchive:  out/linux/amd64/dist\n  Length      Date    Time    Name\n---------  ---------- -----   ----\n        0  02-02-2020 00:00   hello/__init__.py\n      241  02-02-2020 00:00   hello/hello.py\n      288  02-02-2020 00:00   hello-0.1.0.dist-info/METADATA\n       87  02-02-2020 00:00   hello-0.1.0.dist-info/WHEEL\n       42  02-02-2020 00:00   hello-0.1.0.dist-info/entry_points.txt\n      433  02-02-2020 00:00   hello-0.1.0.dist-info/RECORD\n---------                     -------\n     1091                     6 files\n</code></pre> <p>Depending on your local architecture, the path to the artifact may be different.</p>"},{"location":"tutorials/getting_started/#adding-a-blueprint","title":"Adding a Blueprint","text":"<p>Catalyst Forge uses blueprint files in order to both identify projects within a repository as well as configure them. Add a new file in the root of the project folder called <code>blueprint.cue</code> with the following contents:</p> <pre><code>version: \"1.0.0\"\nproject: {\n    name: \"hello-jmgilman\"\n}\n</code></pre> <p>A blueprint file in a directory signifies that it is a project within a repository. Many of the Catalyst automation systems interact with projects inside of a repository and use the existence of this file to distinguish them. For example, without this file, our <code>Earthfile</code> would be ignored by the CI system and none of our targets would run in the pipeline.</p> <p>The only required field in a blueprint file is the project name (shown as <code>hello-jmgilman</code> above). This name should be unique across all repositories and is used to distinguish the project in several area (i.e. the container name). There are many more useful fields exposed in a blueprint file that can be explored later in the documentation.</p>"},{"location":"tutorials/getting_started/#testing-locally","title":"Testing Locally","text":"<p>Prior to pushing our changes in a PR, let's test the full CI pipeline locally:</p> <pre><code>forge ci --local .\n</code></pre> <p>The <code>.</code> parameter is important as it will scope the CI run to only our project. If everything is working correctly, all targets should be run in the correct order and pass with a green checkmark. We've now built our sample application, validated and tested it, and even have potential publish and release artifacts for it.</p>"},{"location":"tutorials/getting_started/#submiting-to-ci","title":"Submiting to CI","text":"<p>Note</p> <p>The CI system in the playground is not connected to any remote build servers for security reasons. As a result, builds will not be cached and will start from scratch each time.</p> <p>Now that we've validated everything locally, we will push our changes to a new branch and open up a PR. After opening the PR, you should see a new GitHub Action workflow start.</p> <p></p> <p>Examining the workflow, you can see that it follows the same steps as was shown in our local run. The only difference is that all projects within the repository are being run in parallel. If any of these projects fail, the entire pipeline will fail. This is intentional, as all projects should be successfully building before merging a PR to the default branch.</p>"},{"location":"tutorials/getting_started/#releasing-and-publishing","title":"Releasing and Publishing","text":"<p>Note</p> <p>The steps below require permissions to merge and tag the playground repository. If you don't have these permissions, you may still read on for educational purposes. Alternatively, you may seek someone out with the necesary permissions to help you (feel free to open an issue!).</p> <p>Once the PR has successfully passed CI, proceed with merging it to the default branch (please use squash merges). After the merge, a new GitHub Workflow will run for this particular commit. Allow the workflow to run to completion before proceeding.</p> <p>Once the workflow has completed, you'll notice a new package created for the GitHub Container Registry. The package will have the same name as the name as defined in <code>project.name</code> and will, by default, have a tag created that matches the commit hash of the merge commit. Whenever a new PR is merged into the default branch, all projects with a publish target will have their respective container images pushed to configured registries using the commit hash as the tag.</p> <p>For the final step, we will tag the repository with an application specific tag:</p> <pre><code>git tag -a \"examples/&lt;username&gt;/v1.0.0\" -m \"My first version\"\ngit push origin master\n</code></pre> <p>This creates a new tag using the traditional \"mono repo\" style tag. The prefix is the path to the project in the repository and the suffix is the semantic version for that project. After creating and pushing this tag, a new workflow is created and the CI pipeline runs again. Allow the new workflow to run to completion before proceeding.</p> <p>Once the workflow is completed, you'll notice that a new release is created on GitHub with the name set to our git tag. The release will contain a single artifact which is the Python wheel created by our <code>release</code> target. Notice that no other projects had a release added. This is the default behavior: only projects which \"match\" the mono repo tag will create a new release and upload assets. All other projects will skip this step.</p>"},{"location":"tutorials/getting_started/#conclusion","title":"Conclusion","text":"<p>That's it for this getting started tutorial. You now understand the fundamentals of creating and managing projects using Catalyst Forge!</p>"}]}