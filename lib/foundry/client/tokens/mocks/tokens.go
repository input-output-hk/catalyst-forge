// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/input-output-hk/catalyst-forge/lib/foundry/client/tokens"
	"sync"
)

// Ensure, that TokensClientInterfaceMock does implement tokens.TokensClientInterface.
// If this is not the case, regenerate this file with moq.
var _ tokens.TokensClientInterface = &TokensClientInterfaceMock{}

// TokensClientInterfaceMock is a mock implementation of tokens.TokensClientInterface.
//
//	func TestSomethingThatUsesTokensClientInterface(t *testing.T) {
//
//		// make and configure a mocked tokens.TokensClientInterface
//		mockedTokensClientInterface := &TokensClientInterfaceMock{
//			RefreshFunc: func(ctx context.Context, req *tokens.RefreshRequest) (*tokens.RefreshResponse, error) {
//				panic("mock out the Refresh method")
//			},
//			RevokeFunc: func(ctx context.Context, req *tokens.RevokeRequest) error {
//				panic("mock out the Revoke method")
//			},
//		}
//
//		// use mockedTokensClientInterface in code that requires tokens.TokensClientInterface
//		// and then make assertions.
//
//	}
type TokensClientInterfaceMock struct {
	// RefreshFunc mocks the Refresh method.
	RefreshFunc func(ctx context.Context, req *tokens.RefreshRequest) (*tokens.RefreshResponse, error)

	// RevokeFunc mocks the Revoke method.
	RevokeFunc func(ctx context.Context, req *tokens.RevokeRequest) error

	// calls tracks calls to the methods.
	calls struct {
		// Refresh holds details about calls to the Refresh method.
		Refresh []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *tokens.RefreshRequest
		}
		// Revoke holds details about calls to the Revoke method.
		Revoke []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *tokens.RevokeRequest
		}
	}
	lockRefresh sync.RWMutex
	lockRevoke  sync.RWMutex
}

// Refresh calls RefreshFunc.
func (mock *TokensClientInterfaceMock) Refresh(ctx context.Context, req *tokens.RefreshRequest) (*tokens.RefreshResponse, error) {
	if mock.RefreshFunc == nil {
		panic("TokensClientInterfaceMock.RefreshFunc: method is nil but TokensClientInterface.Refresh was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *tokens.RefreshRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockRefresh.Lock()
	mock.calls.Refresh = append(mock.calls.Refresh, callInfo)
	mock.lockRefresh.Unlock()
	return mock.RefreshFunc(ctx, req)
}

// RefreshCalls gets all the calls that were made to Refresh.
// Check the length with:
//
//	len(mockedTokensClientInterface.RefreshCalls())
func (mock *TokensClientInterfaceMock) RefreshCalls() []struct {
	Ctx context.Context
	Req *tokens.RefreshRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *tokens.RefreshRequest
	}
	mock.lockRefresh.RLock()
	calls = mock.calls.Refresh
	mock.lockRefresh.RUnlock()
	return calls
}

// Revoke calls RevokeFunc.
func (mock *TokensClientInterfaceMock) Revoke(ctx context.Context, req *tokens.RevokeRequest) error {
	if mock.RevokeFunc == nil {
		panic("TokensClientInterfaceMock.RevokeFunc: method is nil but TokensClientInterface.Revoke was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *tokens.RevokeRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockRevoke.Lock()
	mock.calls.Revoke = append(mock.calls.Revoke, callInfo)
	mock.lockRevoke.Unlock()
	return mock.RevokeFunc(ctx, req)
}

// RevokeCalls gets all the calls that were made to Revoke.
// Check the length with:
//
//	len(mockedTokensClientInterface.RevokeCalls())
func (mock *TokensClientInterfaceMock) RevokeCalls() []struct {
	Ctx context.Context
	Req *tokens.RevokeRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *tokens.RevokeRequest
	}
	mock.lockRevoke.RLock()
	calls = mock.calls.Revoke
	mock.lockRevoke.RUnlock()
	return calls
}
