// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/input-output-hk/catalyst-forge/foundry/api/client"
	"sync"
)

// Ensure, that ClientMock does implement client.Client.
// If this is not the case, regenerate this file with moq.
var _ client.Client = &ClientMock{}

// ClientMock is a mock implementation of client.Client.
//
//	func TestSomethingThatUsesClient(t *testing.T) {
//
//		// make and configure a mocked client.Client
//		mockedClient := &ClientMock{
//			CreateAliasFunc: func(ctx context.Context, aliasName string, releaseID string) error {
//				panic("mock out the CreateAlias method")
//			},
//			CreateDeploymentFunc: func(ctx context.Context, releaseID string) (*client.ReleaseDeployment, error) {
//				panic("mock out the CreateDeployment method")
//			},
//			CreateReleaseFunc: func(ctx context.Context, release *client.Release, deploy bool) (*client.Release, error) {
//				panic("mock out the CreateRelease method")
//			},
//			DeleteAliasFunc: func(ctx context.Context, aliasName string) error {
//				panic("mock out the DeleteAlias method")
//			},
//			GetDeploymentFunc: func(ctx context.Context, releaseID string, deployID string) (*client.ReleaseDeployment, error) {
//				panic("mock out the GetDeployment method")
//			},
//			GetLatestDeploymentFunc: func(ctx context.Context, releaseID string) (*client.ReleaseDeployment, error) {
//				panic("mock out the GetLatestDeployment method")
//			},
//			GetReleaseFunc: func(ctx context.Context, id string) (*client.Release, error) {
//				panic("mock out the GetRelease method")
//			},
//			GetReleaseByAliasFunc: func(ctx context.Context, aliasName string) (*client.Release, error) {
//				panic("mock out the GetReleaseByAlias method")
//			},
//			ListAliasesFunc: func(ctx context.Context, releaseID string) ([]client.ReleaseAlias, error) {
//				panic("mock out the ListAliases method")
//			},
//			ListDeploymentsFunc: func(ctx context.Context, releaseID string) ([]client.ReleaseDeployment, error) {
//				panic("mock out the ListDeployments method")
//			},
//			ListReleasesFunc: func(ctx context.Context, projectName string) ([]client.Release, error) {
//				panic("mock out the ListReleases method")
//			},
//			UpdateDeploymentStatusFunc: func(ctx context.Context, releaseID string, deployID string, status client.DeploymentStatus, reason string) error {
//				panic("mock out the UpdateDeploymentStatus method")
//			},
//			UpdateReleaseFunc: func(ctx context.Context, release *client.Release) (*client.Release, error) {
//				panic("mock out the UpdateRelease method")
//			},
//		}
//
//		// use mockedClient in code that requires client.Client
//		// and then make assertions.
//
//	}
type ClientMock struct {
	// CreateAliasFunc mocks the CreateAlias method.
	CreateAliasFunc func(ctx context.Context, aliasName string, releaseID string) error

	// CreateDeploymentFunc mocks the CreateDeployment method.
	CreateDeploymentFunc func(ctx context.Context, releaseID string) (*client.ReleaseDeployment, error)

	// CreateReleaseFunc mocks the CreateRelease method.
	CreateReleaseFunc func(ctx context.Context, release *client.Release, deploy bool) (*client.Release, error)

	// DeleteAliasFunc mocks the DeleteAlias method.
	DeleteAliasFunc func(ctx context.Context, aliasName string) error

	// GetDeploymentFunc mocks the GetDeployment method.
	GetDeploymentFunc func(ctx context.Context, releaseID string, deployID string) (*client.ReleaseDeployment, error)

	// GetLatestDeploymentFunc mocks the GetLatestDeployment method.
	GetLatestDeploymentFunc func(ctx context.Context, releaseID string) (*client.ReleaseDeployment, error)

	// GetReleaseFunc mocks the GetRelease method.
	GetReleaseFunc func(ctx context.Context, id string) (*client.Release, error)

	// GetReleaseByAliasFunc mocks the GetReleaseByAlias method.
	GetReleaseByAliasFunc func(ctx context.Context, aliasName string) (*client.Release, error)

	// ListAliasesFunc mocks the ListAliases method.
	ListAliasesFunc func(ctx context.Context, releaseID string) ([]client.ReleaseAlias, error)

	// ListDeploymentsFunc mocks the ListDeployments method.
	ListDeploymentsFunc func(ctx context.Context, releaseID string) ([]client.ReleaseDeployment, error)

	// ListReleasesFunc mocks the ListReleases method.
	ListReleasesFunc func(ctx context.Context, projectName string) ([]client.Release, error)

	// UpdateDeploymentStatusFunc mocks the UpdateDeploymentStatus method.
	UpdateDeploymentStatusFunc func(ctx context.Context, releaseID string, deployID string, status client.DeploymentStatus, reason string) error

	// UpdateReleaseFunc mocks the UpdateRelease method.
	UpdateReleaseFunc func(ctx context.Context, release *client.Release) (*client.Release, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateAlias holds details about calls to the CreateAlias method.
		CreateAlias []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AliasName is the aliasName argument value.
			AliasName string
			// ReleaseID is the releaseID argument value.
			ReleaseID string
		}
		// CreateDeployment holds details about calls to the CreateDeployment method.
		CreateDeployment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReleaseID is the releaseID argument value.
			ReleaseID string
		}
		// CreateRelease holds details about calls to the CreateRelease method.
		CreateRelease []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Release is the release argument value.
			Release *client.Release
			// Deploy is the deploy argument value.
			Deploy bool
		}
		// DeleteAlias holds details about calls to the DeleteAlias method.
		DeleteAlias []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AliasName is the aliasName argument value.
			AliasName string
		}
		// GetDeployment holds details about calls to the GetDeployment method.
		GetDeployment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReleaseID is the releaseID argument value.
			ReleaseID string
			// DeployID is the deployID argument value.
			DeployID string
		}
		// GetLatestDeployment holds details about calls to the GetLatestDeployment method.
		GetLatestDeployment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReleaseID is the releaseID argument value.
			ReleaseID string
		}
		// GetRelease holds details about calls to the GetRelease method.
		GetRelease []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetReleaseByAlias holds details about calls to the GetReleaseByAlias method.
		GetReleaseByAlias []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AliasName is the aliasName argument value.
			AliasName string
		}
		// ListAliases holds details about calls to the ListAliases method.
		ListAliases []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReleaseID is the releaseID argument value.
			ReleaseID string
		}
		// ListDeployments holds details about calls to the ListDeployments method.
		ListDeployments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReleaseID is the releaseID argument value.
			ReleaseID string
		}
		// ListReleases holds details about calls to the ListReleases method.
		ListReleases []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProjectName is the projectName argument value.
			ProjectName string
		}
		// UpdateDeploymentStatus holds details about calls to the UpdateDeploymentStatus method.
		UpdateDeploymentStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReleaseID is the releaseID argument value.
			ReleaseID string
			// DeployID is the deployID argument value.
			DeployID string
			// Status is the status argument value.
			Status client.DeploymentStatus
			// Reason is the reason argument value.
			Reason string
		}
		// UpdateRelease holds details about calls to the UpdateRelease method.
		UpdateRelease []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Release is the release argument value.
			Release *client.Release
		}
	}
	lockCreateAlias            sync.RWMutex
	lockCreateDeployment       sync.RWMutex
	lockCreateRelease          sync.RWMutex
	lockDeleteAlias            sync.RWMutex
	lockGetDeployment          sync.RWMutex
	lockGetLatestDeployment    sync.RWMutex
	lockGetRelease             sync.RWMutex
	lockGetReleaseByAlias      sync.RWMutex
	lockListAliases            sync.RWMutex
	lockListDeployments        sync.RWMutex
	lockListReleases           sync.RWMutex
	lockUpdateDeploymentStatus sync.RWMutex
	lockUpdateRelease          sync.RWMutex
}

// CreateAlias calls CreateAliasFunc.
func (mock *ClientMock) CreateAlias(ctx context.Context, aliasName string, releaseID string) error {
	if mock.CreateAliasFunc == nil {
		panic("ClientMock.CreateAliasFunc: method is nil but Client.CreateAlias was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		AliasName string
		ReleaseID string
	}{
		Ctx:       ctx,
		AliasName: aliasName,
		ReleaseID: releaseID,
	}
	mock.lockCreateAlias.Lock()
	mock.calls.CreateAlias = append(mock.calls.CreateAlias, callInfo)
	mock.lockCreateAlias.Unlock()
	return mock.CreateAliasFunc(ctx, aliasName, releaseID)
}

// CreateAliasCalls gets all the calls that were made to CreateAlias.
// Check the length with:
//
//	len(mockedClient.CreateAliasCalls())
func (mock *ClientMock) CreateAliasCalls() []struct {
	Ctx       context.Context
	AliasName string
	ReleaseID string
} {
	var calls []struct {
		Ctx       context.Context
		AliasName string
		ReleaseID string
	}
	mock.lockCreateAlias.RLock()
	calls = mock.calls.CreateAlias
	mock.lockCreateAlias.RUnlock()
	return calls
}

// CreateDeployment calls CreateDeploymentFunc.
func (mock *ClientMock) CreateDeployment(ctx context.Context, releaseID string) (*client.ReleaseDeployment, error) {
	if mock.CreateDeploymentFunc == nil {
		panic("ClientMock.CreateDeploymentFunc: method is nil but Client.CreateDeployment was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ReleaseID string
	}{
		Ctx:       ctx,
		ReleaseID: releaseID,
	}
	mock.lockCreateDeployment.Lock()
	mock.calls.CreateDeployment = append(mock.calls.CreateDeployment, callInfo)
	mock.lockCreateDeployment.Unlock()
	return mock.CreateDeploymentFunc(ctx, releaseID)
}

// CreateDeploymentCalls gets all the calls that were made to CreateDeployment.
// Check the length with:
//
//	len(mockedClient.CreateDeploymentCalls())
func (mock *ClientMock) CreateDeploymentCalls() []struct {
	Ctx       context.Context
	ReleaseID string
} {
	var calls []struct {
		Ctx       context.Context
		ReleaseID string
	}
	mock.lockCreateDeployment.RLock()
	calls = mock.calls.CreateDeployment
	mock.lockCreateDeployment.RUnlock()
	return calls
}

// CreateRelease calls CreateReleaseFunc.
func (mock *ClientMock) CreateRelease(ctx context.Context, release *client.Release, deploy bool) (*client.Release, error) {
	if mock.CreateReleaseFunc == nil {
		panic("ClientMock.CreateReleaseFunc: method is nil but Client.CreateRelease was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Release *client.Release
		Deploy  bool
	}{
		Ctx:     ctx,
		Release: release,
		Deploy:  deploy,
	}
	mock.lockCreateRelease.Lock()
	mock.calls.CreateRelease = append(mock.calls.CreateRelease, callInfo)
	mock.lockCreateRelease.Unlock()
	return mock.CreateReleaseFunc(ctx, release, deploy)
}

// CreateReleaseCalls gets all the calls that were made to CreateRelease.
// Check the length with:
//
//	len(mockedClient.CreateReleaseCalls())
func (mock *ClientMock) CreateReleaseCalls() []struct {
	Ctx     context.Context
	Release *client.Release
	Deploy  bool
} {
	var calls []struct {
		Ctx     context.Context
		Release *client.Release
		Deploy  bool
	}
	mock.lockCreateRelease.RLock()
	calls = mock.calls.CreateRelease
	mock.lockCreateRelease.RUnlock()
	return calls
}

// DeleteAlias calls DeleteAliasFunc.
func (mock *ClientMock) DeleteAlias(ctx context.Context, aliasName string) error {
	if mock.DeleteAliasFunc == nil {
		panic("ClientMock.DeleteAliasFunc: method is nil but Client.DeleteAlias was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		AliasName string
	}{
		Ctx:       ctx,
		AliasName: aliasName,
	}
	mock.lockDeleteAlias.Lock()
	mock.calls.DeleteAlias = append(mock.calls.DeleteAlias, callInfo)
	mock.lockDeleteAlias.Unlock()
	return mock.DeleteAliasFunc(ctx, aliasName)
}

// DeleteAliasCalls gets all the calls that were made to DeleteAlias.
// Check the length with:
//
//	len(mockedClient.DeleteAliasCalls())
func (mock *ClientMock) DeleteAliasCalls() []struct {
	Ctx       context.Context
	AliasName string
} {
	var calls []struct {
		Ctx       context.Context
		AliasName string
	}
	mock.lockDeleteAlias.RLock()
	calls = mock.calls.DeleteAlias
	mock.lockDeleteAlias.RUnlock()
	return calls
}

// GetDeployment calls GetDeploymentFunc.
func (mock *ClientMock) GetDeployment(ctx context.Context, releaseID string, deployID string) (*client.ReleaseDeployment, error) {
	if mock.GetDeploymentFunc == nil {
		panic("ClientMock.GetDeploymentFunc: method is nil but Client.GetDeployment was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ReleaseID string
		DeployID  string
	}{
		Ctx:       ctx,
		ReleaseID: releaseID,
		DeployID:  deployID,
	}
	mock.lockGetDeployment.Lock()
	mock.calls.GetDeployment = append(mock.calls.GetDeployment, callInfo)
	mock.lockGetDeployment.Unlock()
	return mock.GetDeploymentFunc(ctx, releaseID, deployID)
}

// GetDeploymentCalls gets all the calls that were made to GetDeployment.
// Check the length with:
//
//	len(mockedClient.GetDeploymentCalls())
func (mock *ClientMock) GetDeploymentCalls() []struct {
	Ctx       context.Context
	ReleaseID string
	DeployID  string
} {
	var calls []struct {
		Ctx       context.Context
		ReleaseID string
		DeployID  string
	}
	mock.lockGetDeployment.RLock()
	calls = mock.calls.GetDeployment
	mock.lockGetDeployment.RUnlock()
	return calls
}

// GetLatestDeployment calls GetLatestDeploymentFunc.
func (mock *ClientMock) GetLatestDeployment(ctx context.Context, releaseID string) (*client.ReleaseDeployment, error) {
	if mock.GetLatestDeploymentFunc == nil {
		panic("ClientMock.GetLatestDeploymentFunc: method is nil but Client.GetLatestDeployment was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ReleaseID string
	}{
		Ctx:       ctx,
		ReleaseID: releaseID,
	}
	mock.lockGetLatestDeployment.Lock()
	mock.calls.GetLatestDeployment = append(mock.calls.GetLatestDeployment, callInfo)
	mock.lockGetLatestDeployment.Unlock()
	return mock.GetLatestDeploymentFunc(ctx, releaseID)
}

// GetLatestDeploymentCalls gets all the calls that were made to GetLatestDeployment.
// Check the length with:
//
//	len(mockedClient.GetLatestDeploymentCalls())
func (mock *ClientMock) GetLatestDeploymentCalls() []struct {
	Ctx       context.Context
	ReleaseID string
} {
	var calls []struct {
		Ctx       context.Context
		ReleaseID string
	}
	mock.lockGetLatestDeployment.RLock()
	calls = mock.calls.GetLatestDeployment
	mock.lockGetLatestDeployment.RUnlock()
	return calls
}

// GetRelease calls GetReleaseFunc.
func (mock *ClientMock) GetRelease(ctx context.Context, id string) (*client.Release, error) {
	if mock.GetReleaseFunc == nil {
		panic("ClientMock.GetReleaseFunc: method is nil but Client.GetRelease was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetRelease.Lock()
	mock.calls.GetRelease = append(mock.calls.GetRelease, callInfo)
	mock.lockGetRelease.Unlock()
	return mock.GetReleaseFunc(ctx, id)
}

// GetReleaseCalls gets all the calls that were made to GetRelease.
// Check the length with:
//
//	len(mockedClient.GetReleaseCalls())
func (mock *ClientMock) GetReleaseCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetRelease.RLock()
	calls = mock.calls.GetRelease
	mock.lockGetRelease.RUnlock()
	return calls
}

// GetReleaseByAlias calls GetReleaseByAliasFunc.
func (mock *ClientMock) GetReleaseByAlias(ctx context.Context, aliasName string) (*client.Release, error) {
	if mock.GetReleaseByAliasFunc == nil {
		panic("ClientMock.GetReleaseByAliasFunc: method is nil but Client.GetReleaseByAlias was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		AliasName string
	}{
		Ctx:       ctx,
		AliasName: aliasName,
	}
	mock.lockGetReleaseByAlias.Lock()
	mock.calls.GetReleaseByAlias = append(mock.calls.GetReleaseByAlias, callInfo)
	mock.lockGetReleaseByAlias.Unlock()
	return mock.GetReleaseByAliasFunc(ctx, aliasName)
}

// GetReleaseByAliasCalls gets all the calls that were made to GetReleaseByAlias.
// Check the length with:
//
//	len(mockedClient.GetReleaseByAliasCalls())
func (mock *ClientMock) GetReleaseByAliasCalls() []struct {
	Ctx       context.Context
	AliasName string
} {
	var calls []struct {
		Ctx       context.Context
		AliasName string
	}
	mock.lockGetReleaseByAlias.RLock()
	calls = mock.calls.GetReleaseByAlias
	mock.lockGetReleaseByAlias.RUnlock()
	return calls
}

// ListAliases calls ListAliasesFunc.
func (mock *ClientMock) ListAliases(ctx context.Context, releaseID string) ([]client.ReleaseAlias, error) {
	if mock.ListAliasesFunc == nil {
		panic("ClientMock.ListAliasesFunc: method is nil but Client.ListAliases was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ReleaseID string
	}{
		Ctx:       ctx,
		ReleaseID: releaseID,
	}
	mock.lockListAliases.Lock()
	mock.calls.ListAliases = append(mock.calls.ListAliases, callInfo)
	mock.lockListAliases.Unlock()
	return mock.ListAliasesFunc(ctx, releaseID)
}

// ListAliasesCalls gets all the calls that were made to ListAliases.
// Check the length with:
//
//	len(mockedClient.ListAliasesCalls())
func (mock *ClientMock) ListAliasesCalls() []struct {
	Ctx       context.Context
	ReleaseID string
} {
	var calls []struct {
		Ctx       context.Context
		ReleaseID string
	}
	mock.lockListAliases.RLock()
	calls = mock.calls.ListAliases
	mock.lockListAliases.RUnlock()
	return calls
}

// ListDeployments calls ListDeploymentsFunc.
func (mock *ClientMock) ListDeployments(ctx context.Context, releaseID string) ([]client.ReleaseDeployment, error) {
	if mock.ListDeploymentsFunc == nil {
		panic("ClientMock.ListDeploymentsFunc: method is nil but Client.ListDeployments was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ReleaseID string
	}{
		Ctx:       ctx,
		ReleaseID: releaseID,
	}
	mock.lockListDeployments.Lock()
	mock.calls.ListDeployments = append(mock.calls.ListDeployments, callInfo)
	mock.lockListDeployments.Unlock()
	return mock.ListDeploymentsFunc(ctx, releaseID)
}

// ListDeploymentsCalls gets all the calls that were made to ListDeployments.
// Check the length with:
//
//	len(mockedClient.ListDeploymentsCalls())
func (mock *ClientMock) ListDeploymentsCalls() []struct {
	Ctx       context.Context
	ReleaseID string
} {
	var calls []struct {
		Ctx       context.Context
		ReleaseID string
	}
	mock.lockListDeployments.RLock()
	calls = mock.calls.ListDeployments
	mock.lockListDeployments.RUnlock()
	return calls
}

// ListReleases calls ListReleasesFunc.
func (mock *ClientMock) ListReleases(ctx context.Context, projectName string) ([]client.Release, error) {
	if mock.ListReleasesFunc == nil {
		panic("ClientMock.ListReleasesFunc: method is nil but Client.ListReleases was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		ProjectName string
	}{
		Ctx:         ctx,
		ProjectName: projectName,
	}
	mock.lockListReleases.Lock()
	mock.calls.ListReleases = append(mock.calls.ListReleases, callInfo)
	mock.lockListReleases.Unlock()
	return mock.ListReleasesFunc(ctx, projectName)
}

// ListReleasesCalls gets all the calls that were made to ListReleases.
// Check the length with:
//
//	len(mockedClient.ListReleasesCalls())
func (mock *ClientMock) ListReleasesCalls() []struct {
	Ctx         context.Context
	ProjectName string
} {
	var calls []struct {
		Ctx         context.Context
		ProjectName string
	}
	mock.lockListReleases.RLock()
	calls = mock.calls.ListReleases
	mock.lockListReleases.RUnlock()
	return calls
}

// UpdateDeploymentStatus calls UpdateDeploymentStatusFunc.
func (mock *ClientMock) UpdateDeploymentStatus(ctx context.Context, releaseID string, deployID string, status client.DeploymentStatus, reason string) error {
	if mock.UpdateDeploymentStatusFunc == nil {
		panic("ClientMock.UpdateDeploymentStatusFunc: method is nil but Client.UpdateDeploymentStatus was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ReleaseID string
		DeployID  string
		Status    client.DeploymentStatus
		Reason    string
	}{
		Ctx:       ctx,
		ReleaseID: releaseID,
		DeployID:  deployID,
		Status:    status,
		Reason:    reason,
	}
	mock.lockUpdateDeploymentStatus.Lock()
	mock.calls.UpdateDeploymentStatus = append(mock.calls.UpdateDeploymentStatus, callInfo)
	mock.lockUpdateDeploymentStatus.Unlock()
	return mock.UpdateDeploymentStatusFunc(ctx, releaseID, deployID, status, reason)
}

// UpdateDeploymentStatusCalls gets all the calls that were made to UpdateDeploymentStatus.
// Check the length with:
//
//	len(mockedClient.UpdateDeploymentStatusCalls())
func (mock *ClientMock) UpdateDeploymentStatusCalls() []struct {
	Ctx       context.Context
	ReleaseID string
	DeployID  string
	Status    client.DeploymentStatus
	Reason    string
} {
	var calls []struct {
		Ctx       context.Context
		ReleaseID string
		DeployID  string
		Status    client.DeploymentStatus
		Reason    string
	}
	mock.lockUpdateDeploymentStatus.RLock()
	calls = mock.calls.UpdateDeploymentStatus
	mock.lockUpdateDeploymentStatus.RUnlock()
	return calls
}

// UpdateRelease calls UpdateReleaseFunc.
func (mock *ClientMock) UpdateRelease(ctx context.Context, release *client.Release) (*client.Release, error) {
	if mock.UpdateReleaseFunc == nil {
		panic("ClientMock.UpdateReleaseFunc: method is nil but Client.UpdateRelease was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Release *client.Release
	}{
		Ctx:     ctx,
		Release: release,
	}
	mock.lockUpdateRelease.Lock()
	mock.calls.UpdateRelease = append(mock.calls.UpdateRelease, callInfo)
	mock.lockUpdateRelease.Unlock()
	return mock.UpdateReleaseFunc(ctx, release)
}

// UpdateReleaseCalls gets all the calls that were made to UpdateRelease.
// Check the length with:
//
//	len(mockedClient.UpdateReleaseCalls())
func (mock *ClientMock) UpdateReleaseCalls() []struct {
	Ctx     context.Context
	Release *client.Release
} {
	var calls []struct {
		Ctx     context.Context
		Release *client.Release
	}
	mock.lockUpdateRelease.RLock()
	calls = mock.calls.UpdateRelease
	mock.lockUpdateRelease.RUnlock()
	return calls
}
