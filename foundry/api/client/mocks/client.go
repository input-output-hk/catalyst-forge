// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/input-output-hk/catalyst-forge/foundry/api/client"
	"sync"
)

// Ensure, that ClientMock does implement client.Client.
// If this is not the case, regenerate this file with moq.
var _ client.Client = &ClientMock{}

// ClientMock is a mock implementation of client.Client.
//
//	func TestSomethingThatUsesClient(t *testing.T) {
//
//		// make and configure a mocked client.Client
//		mockedClient := &ClientMock{
//			AddDeploymentEventFunc: func(ctx context.Context, releaseID string, deployID string, name string, message string) (*client.ReleaseDeployment, error) {
//				panic("mock out the AddDeploymentEvent method")
//			},
//			CreateAliasFunc: func(ctx context.Context, aliasName string, releaseID string) error {
//				panic("mock out the CreateAlias method")
//			},
//			CreateAuthFunc: func(ctx context.Context, req *client.CreateAuthRequest) (*client.GHARepositoryAuth, error) {
//				panic("mock out the CreateAuth method")
//			},
//			CreateDeploymentFunc: func(ctx context.Context, releaseID string) (*client.ReleaseDeployment, error) {
//				panic("mock out the CreateDeployment method")
//			},
//			CreateReleaseFunc: func(ctx context.Context, release *client.Release, deploy bool) (*client.Release, error) {
//				panic("mock out the CreateRelease method")
//			},
//			DeleteAliasFunc: func(ctx context.Context, aliasName string) error {
//				panic("mock out the DeleteAlias method")
//			},
//			DeleteAuthFunc: func(ctx context.Context, id uint) error {
//				panic("mock out the DeleteAuth method")
//			},
//			GetAuthFunc: func(ctx context.Context, id uint) (*client.GHARepositoryAuth, error) {
//				panic("mock out the GetAuth method")
//			},
//			GetAuthByRepositoryFunc: func(ctx context.Context, repository string) (*client.GHARepositoryAuth, error) {
//				panic("mock out the GetAuthByRepository method")
//			},
//			GetDeploymentFunc: func(ctx context.Context, releaseID string, deployID string) (*client.ReleaseDeployment, error) {
//				panic("mock out the GetDeployment method")
//			},
//			GetDeploymentEventsFunc: func(ctx context.Context, releaseID string, deployID string) ([]client.DeploymentEvent, error) {
//				panic("mock out the GetDeploymentEvents method")
//			},
//			GetLatestDeploymentFunc: func(ctx context.Context, releaseID string) (*client.ReleaseDeployment, error) {
//				panic("mock out the GetLatestDeployment method")
//			},
//			GetReleaseFunc: func(ctx context.Context, id string) (*client.Release, error) {
//				panic("mock out the GetRelease method")
//			},
//			GetReleaseByAliasFunc: func(ctx context.Context, aliasName string) (*client.Release, error) {
//				panic("mock out the GetReleaseByAlias method")
//			},
//			IncrementDeploymentAttemptsFunc: func(ctx context.Context, releaseID string, deployID string) (*client.ReleaseDeployment, error) {
//				panic("mock out the IncrementDeploymentAttempts method")
//			},
//			ListAliasesFunc: func(ctx context.Context, releaseID string) ([]client.ReleaseAlias, error) {
//				panic("mock out the ListAliases method")
//			},
//			ListAuthsFunc: func(ctx context.Context) ([]client.GHARepositoryAuth, error) {
//				panic("mock out the ListAuths method")
//			},
//			ListDeploymentsFunc: func(ctx context.Context, releaseID string) ([]client.ReleaseDeployment, error) {
//				panic("mock out the ListDeployments method")
//			},
//			ListReleasesFunc: func(ctx context.Context, projectName string) ([]client.Release, error) {
//				panic("mock out the ListReleases method")
//			},
//			UpdateAuthFunc: func(ctx context.Context, id uint, req *client.UpdateAuthRequest) (*client.GHARepositoryAuth, error) {
//				panic("mock out the UpdateAuth method")
//			},
//			UpdateDeploymentFunc: func(ctx context.Context, releaseID string, deployment *client.ReleaseDeployment) (*client.ReleaseDeployment, error) {
//				panic("mock out the UpdateDeployment method")
//			},
//			UpdateReleaseFunc: func(ctx context.Context, release *client.Release) (*client.Release, error) {
//				panic("mock out the UpdateRelease method")
//			},
//			ValidateTokenFunc: func(ctx context.Context, req *client.ValidateTokenRequest) (*client.ValidateTokenResponse, error) {
//				panic("mock out the ValidateToken method")
//			},
//		}
//
//		// use mockedClient in code that requires client.Client
//		// and then make assertions.
//
//	}
type ClientMock struct {
	// AddDeploymentEventFunc mocks the AddDeploymentEvent method.
	AddDeploymentEventFunc func(ctx context.Context, releaseID string, deployID string, name string, message string) (*client.ReleaseDeployment, error)

	// CreateAliasFunc mocks the CreateAlias method.
	CreateAliasFunc func(ctx context.Context, aliasName string, releaseID string) error

	// CreateAuthFunc mocks the CreateAuth method.
	CreateAuthFunc func(ctx context.Context, req *client.CreateAuthRequest) (*client.GHARepositoryAuth, error)

	// CreateDeploymentFunc mocks the CreateDeployment method.
	CreateDeploymentFunc func(ctx context.Context, releaseID string) (*client.ReleaseDeployment, error)

	// CreateReleaseFunc mocks the CreateRelease method.
	CreateReleaseFunc func(ctx context.Context, release *client.Release, deploy bool) (*client.Release, error)

	// DeleteAliasFunc mocks the DeleteAlias method.
	DeleteAliasFunc func(ctx context.Context, aliasName string) error

	// DeleteAuthFunc mocks the DeleteAuth method.
	DeleteAuthFunc func(ctx context.Context, id uint) error

	// GetAuthFunc mocks the GetAuth method.
	GetAuthFunc func(ctx context.Context, id uint) (*client.GHARepositoryAuth, error)

	// GetAuthByRepositoryFunc mocks the GetAuthByRepository method.
	GetAuthByRepositoryFunc func(ctx context.Context, repository string) (*client.GHARepositoryAuth, error)

	// GetDeploymentFunc mocks the GetDeployment method.
	GetDeploymentFunc func(ctx context.Context, releaseID string, deployID string) (*client.ReleaseDeployment, error)

	// GetDeploymentEventsFunc mocks the GetDeploymentEvents method.
	GetDeploymentEventsFunc func(ctx context.Context, releaseID string, deployID string) ([]client.DeploymentEvent, error)

	// GetLatestDeploymentFunc mocks the GetLatestDeployment method.
	GetLatestDeploymentFunc func(ctx context.Context, releaseID string) (*client.ReleaseDeployment, error)

	// GetReleaseFunc mocks the GetRelease method.
	GetReleaseFunc func(ctx context.Context, id string) (*client.Release, error)

	// GetReleaseByAliasFunc mocks the GetReleaseByAlias method.
	GetReleaseByAliasFunc func(ctx context.Context, aliasName string) (*client.Release, error)

	// IncrementDeploymentAttemptsFunc mocks the IncrementDeploymentAttempts method.
	IncrementDeploymentAttemptsFunc func(ctx context.Context, releaseID string, deployID string) (*client.ReleaseDeployment, error)

	// ListAliasesFunc mocks the ListAliases method.
	ListAliasesFunc func(ctx context.Context, releaseID string) ([]client.ReleaseAlias, error)

	// ListAuthsFunc mocks the ListAuths method.
	ListAuthsFunc func(ctx context.Context) ([]client.GHARepositoryAuth, error)

	// ListDeploymentsFunc mocks the ListDeployments method.
	ListDeploymentsFunc func(ctx context.Context, releaseID string) ([]client.ReleaseDeployment, error)

	// ListReleasesFunc mocks the ListReleases method.
	ListReleasesFunc func(ctx context.Context, projectName string) ([]client.Release, error)

	// UpdateAuthFunc mocks the UpdateAuth method.
	UpdateAuthFunc func(ctx context.Context, id uint, req *client.UpdateAuthRequest) (*client.GHARepositoryAuth, error)

	// UpdateDeploymentFunc mocks the UpdateDeployment method.
	UpdateDeploymentFunc func(ctx context.Context, releaseID string, deployment *client.ReleaseDeployment) (*client.ReleaseDeployment, error)

	// UpdateReleaseFunc mocks the UpdateRelease method.
	UpdateReleaseFunc func(ctx context.Context, release *client.Release) (*client.Release, error)

	// ValidateTokenFunc mocks the ValidateToken method.
	ValidateTokenFunc func(ctx context.Context, req *client.ValidateTokenRequest) (*client.ValidateTokenResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddDeploymentEvent holds details about calls to the AddDeploymentEvent method.
		AddDeploymentEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReleaseID is the releaseID argument value.
			ReleaseID string
			// DeployID is the deployID argument value.
			DeployID string
			// Name is the name argument value.
			Name string
			// Message is the message argument value.
			Message string
		}
		// CreateAlias holds details about calls to the CreateAlias method.
		CreateAlias []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AliasName is the aliasName argument value.
			AliasName string
			// ReleaseID is the releaseID argument value.
			ReleaseID string
		}
		// CreateAuth holds details about calls to the CreateAuth method.
		CreateAuth []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *client.CreateAuthRequest
		}
		// CreateDeployment holds details about calls to the CreateDeployment method.
		CreateDeployment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReleaseID is the releaseID argument value.
			ReleaseID string
		}
		// CreateRelease holds details about calls to the CreateRelease method.
		CreateRelease []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Release is the release argument value.
			Release *client.Release
			// Deploy is the deploy argument value.
			Deploy bool
		}
		// DeleteAlias holds details about calls to the DeleteAlias method.
		DeleteAlias []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AliasName is the aliasName argument value.
			AliasName string
		}
		// DeleteAuth holds details about calls to the DeleteAuth method.
		DeleteAuth []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uint
		}
		// GetAuth holds details about calls to the GetAuth method.
		GetAuth []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uint
		}
		// GetAuthByRepository holds details about calls to the GetAuthByRepository method.
		GetAuthByRepository []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Repository is the repository argument value.
			Repository string
		}
		// GetDeployment holds details about calls to the GetDeployment method.
		GetDeployment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReleaseID is the releaseID argument value.
			ReleaseID string
			// DeployID is the deployID argument value.
			DeployID string
		}
		// GetDeploymentEvents holds details about calls to the GetDeploymentEvents method.
		GetDeploymentEvents []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReleaseID is the releaseID argument value.
			ReleaseID string
			// DeployID is the deployID argument value.
			DeployID string
		}
		// GetLatestDeployment holds details about calls to the GetLatestDeployment method.
		GetLatestDeployment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReleaseID is the releaseID argument value.
			ReleaseID string
		}
		// GetRelease holds details about calls to the GetRelease method.
		GetRelease []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetReleaseByAlias holds details about calls to the GetReleaseByAlias method.
		GetReleaseByAlias []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AliasName is the aliasName argument value.
			AliasName string
		}
		// IncrementDeploymentAttempts holds details about calls to the IncrementDeploymentAttempts method.
		IncrementDeploymentAttempts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReleaseID is the releaseID argument value.
			ReleaseID string
			// DeployID is the deployID argument value.
			DeployID string
		}
		// ListAliases holds details about calls to the ListAliases method.
		ListAliases []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReleaseID is the releaseID argument value.
			ReleaseID string
		}
		// ListAuths holds details about calls to the ListAuths method.
		ListAuths []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListDeployments holds details about calls to the ListDeployments method.
		ListDeployments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReleaseID is the releaseID argument value.
			ReleaseID string
		}
		// ListReleases holds details about calls to the ListReleases method.
		ListReleases []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProjectName is the projectName argument value.
			ProjectName string
		}
		// UpdateAuth holds details about calls to the UpdateAuth method.
		UpdateAuth []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uint
			// Req is the req argument value.
			Req *client.UpdateAuthRequest
		}
		// UpdateDeployment holds details about calls to the UpdateDeployment method.
		UpdateDeployment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReleaseID is the releaseID argument value.
			ReleaseID string
			// Deployment is the deployment argument value.
			Deployment *client.ReleaseDeployment
		}
		// UpdateRelease holds details about calls to the UpdateRelease method.
		UpdateRelease []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Release is the release argument value.
			Release *client.Release
		}
		// ValidateToken holds details about calls to the ValidateToken method.
		ValidateToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *client.ValidateTokenRequest
		}
	}
	lockAddDeploymentEvent          sync.RWMutex
	lockCreateAlias                 sync.RWMutex
	lockCreateAuth                  sync.RWMutex
	lockCreateDeployment            sync.RWMutex
	lockCreateRelease               sync.RWMutex
	lockDeleteAlias                 sync.RWMutex
	lockDeleteAuth                  sync.RWMutex
	lockGetAuth                     sync.RWMutex
	lockGetAuthByRepository         sync.RWMutex
	lockGetDeployment               sync.RWMutex
	lockGetDeploymentEvents         sync.RWMutex
	lockGetLatestDeployment         sync.RWMutex
	lockGetRelease                  sync.RWMutex
	lockGetReleaseByAlias           sync.RWMutex
	lockIncrementDeploymentAttempts sync.RWMutex
	lockListAliases                 sync.RWMutex
	lockListAuths                   sync.RWMutex
	lockListDeployments             sync.RWMutex
	lockListReleases                sync.RWMutex
	lockUpdateAuth                  sync.RWMutex
	lockUpdateDeployment            sync.RWMutex
	lockUpdateRelease               sync.RWMutex
	lockValidateToken               sync.RWMutex
}

// AddDeploymentEvent calls AddDeploymentEventFunc.
func (mock *ClientMock) AddDeploymentEvent(ctx context.Context, releaseID string, deployID string, name string, message string) (*client.ReleaseDeployment, error) {
	if mock.AddDeploymentEventFunc == nil {
		panic("ClientMock.AddDeploymentEventFunc: method is nil but Client.AddDeploymentEvent was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ReleaseID string
		DeployID  string
		Name      string
		Message   string
	}{
		Ctx:       ctx,
		ReleaseID: releaseID,
		DeployID:  deployID,
		Name:      name,
		Message:   message,
	}
	mock.lockAddDeploymentEvent.Lock()
	mock.calls.AddDeploymentEvent = append(mock.calls.AddDeploymentEvent, callInfo)
	mock.lockAddDeploymentEvent.Unlock()
	return mock.AddDeploymentEventFunc(ctx, releaseID, deployID, name, message)
}

// AddDeploymentEventCalls gets all the calls that were made to AddDeploymentEvent.
// Check the length with:
//
//	len(mockedClient.AddDeploymentEventCalls())
func (mock *ClientMock) AddDeploymentEventCalls() []struct {
	Ctx       context.Context
	ReleaseID string
	DeployID  string
	Name      string
	Message   string
} {
	var calls []struct {
		Ctx       context.Context
		ReleaseID string
		DeployID  string
		Name      string
		Message   string
	}
	mock.lockAddDeploymentEvent.RLock()
	calls = mock.calls.AddDeploymentEvent
	mock.lockAddDeploymentEvent.RUnlock()
	return calls
}

// CreateAlias calls CreateAliasFunc.
func (mock *ClientMock) CreateAlias(ctx context.Context, aliasName string, releaseID string) error {
	if mock.CreateAliasFunc == nil {
		panic("ClientMock.CreateAliasFunc: method is nil but Client.CreateAlias was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		AliasName string
		ReleaseID string
	}{
		Ctx:       ctx,
		AliasName: aliasName,
		ReleaseID: releaseID,
	}
	mock.lockCreateAlias.Lock()
	mock.calls.CreateAlias = append(mock.calls.CreateAlias, callInfo)
	mock.lockCreateAlias.Unlock()
	return mock.CreateAliasFunc(ctx, aliasName, releaseID)
}

// CreateAliasCalls gets all the calls that were made to CreateAlias.
// Check the length with:
//
//	len(mockedClient.CreateAliasCalls())
func (mock *ClientMock) CreateAliasCalls() []struct {
	Ctx       context.Context
	AliasName string
	ReleaseID string
} {
	var calls []struct {
		Ctx       context.Context
		AliasName string
		ReleaseID string
	}
	mock.lockCreateAlias.RLock()
	calls = mock.calls.CreateAlias
	mock.lockCreateAlias.RUnlock()
	return calls
}

// CreateAuth calls CreateAuthFunc.
func (mock *ClientMock) CreateAuth(ctx context.Context, req *client.CreateAuthRequest) (*client.GHARepositoryAuth, error) {
	if mock.CreateAuthFunc == nil {
		panic("ClientMock.CreateAuthFunc: method is nil but Client.CreateAuth was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *client.CreateAuthRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockCreateAuth.Lock()
	mock.calls.CreateAuth = append(mock.calls.CreateAuth, callInfo)
	mock.lockCreateAuth.Unlock()
	return mock.CreateAuthFunc(ctx, req)
}

// CreateAuthCalls gets all the calls that were made to CreateAuth.
// Check the length with:
//
//	len(mockedClient.CreateAuthCalls())
func (mock *ClientMock) CreateAuthCalls() []struct {
	Ctx context.Context
	Req *client.CreateAuthRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *client.CreateAuthRequest
	}
	mock.lockCreateAuth.RLock()
	calls = mock.calls.CreateAuth
	mock.lockCreateAuth.RUnlock()
	return calls
}

// CreateDeployment calls CreateDeploymentFunc.
func (mock *ClientMock) CreateDeployment(ctx context.Context, releaseID string) (*client.ReleaseDeployment, error) {
	if mock.CreateDeploymentFunc == nil {
		panic("ClientMock.CreateDeploymentFunc: method is nil but Client.CreateDeployment was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ReleaseID string
	}{
		Ctx:       ctx,
		ReleaseID: releaseID,
	}
	mock.lockCreateDeployment.Lock()
	mock.calls.CreateDeployment = append(mock.calls.CreateDeployment, callInfo)
	mock.lockCreateDeployment.Unlock()
	return mock.CreateDeploymentFunc(ctx, releaseID)
}

// CreateDeploymentCalls gets all the calls that were made to CreateDeployment.
// Check the length with:
//
//	len(mockedClient.CreateDeploymentCalls())
func (mock *ClientMock) CreateDeploymentCalls() []struct {
	Ctx       context.Context
	ReleaseID string
} {
	var calls []struct {
		Ctx       context.Context
		ReleaseID string
	}
	mock.lockCreateDeployment.RLock()
	calls = mock.calls.CreateDeployment
	mock.lockCreateDeployment.RUnlock()
	return calls
}

// CreateRelease calls CreateReleaseFunc.
func (mock *ClientMock) CreateRelease(ctx context.Context, release *client.Release, deploy bool) (*client.Release, error) {
	if mock.CreateReleaseFunc == nil {
		panic("ClientMock.CreateReleaseFunc: method is nil but Client.CreateRelease was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Release *client.Release
		Deploy  bool
	}{
		Ctx:     ctx,
		Release: release,
		Deploy:  deploy,
	}
	mock.lockCreateRelease.Lock()
	mock.calls.CreateRelease = append(mock.calls.CreateRelease, callInfo)
	mock.lockCreateRelease.Unlock()
	return mock.CreateReleaseFunc(ctx, release, deploy)
}

// CreateReleaseCalls gets all the calls that were made to CreateRelease.
// Check the length with:
//
//	len(mockedClient.CreateReleaseCalls())
func (mock *ClientMock) CreateReleaseCalls() []struct {
	Ctx     context.Context
	Release *client.Release
	Deploy  bool
} {
	var calls []struct {
		Ctx     context.Context
		Release *client.Release
		Deploy  bool
	}
	mock.lockCreateRelease.RLock()
	calls = mock.calls.CreateRelease
	mock.lockCreateRelease.RUnlock()
	return calls
}

// DeleteAlias calls DeleteAliasFunc.
func (mock *ClientMock) DeleteAlias(ctx context.Context, aliasName string) error {
	if mock.DeleteAliasFunc == nil {
		panic("ClientMock.DeleteAliasFunc: method is nil but Client.DeleteAlias was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		AliasName string
	}{
		Ctx:       ctx,
		AliasName: aliasName,
	}
	mock.lockDeleteAlias.Lock()
	mock.calls.DeleteAlias = append(mock.calls.DeleteAlias, callInfo)
	mock.lockDeleteAlias.Unlock()
	return mock.DeleteAliasFunc(ctx, aliasName)
}

// DeleteAliasCalls gets all the calls that were made to DeleteAlias.
// Check the length with:
//
//	len(mockedClient.DeleteAliasCalls())
func (mock *ClientMock) DeleteAliasCalls() []struct {
	Ctx       context.Context
	AliasName string
} {
	var calls []struct {
		Ctx       context.Context
		AliasName string
	}
	mock.lockDeleteAlias.RLock()
	calls = mock.calls.DeleteAlias
	mock.lockDeleteAlias.RUnlock()
	return calls
}

// DeleteAuth calls DeleteAuthFunc.
func (mock *ClientMock) DeleteAuth(ctx context.Context, id uint) error {
	if mock.DeleteAuthFunc == nil {
		panic("ClientMock.DeleteAuthFunc: method is nil but Client.DeleteAuth was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uint
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteAuth.Lock()
	mock.calls.DeleteAuth = append(mock.calls.DeleteAuth, callInfo)
	mock.lockDeleteAuth.Unlock()
	return mock.DeleteAuthFunc(ctx, id)
}

// DeleteAuthCalls gets all the calls that were made to DeleteAuth.
// Check the length with:
//
//	len(mockedClient.DeleteAuthCalls())
func (mock *ClientMock) DeleteAuthCalls() []struct {
	Ctx context.Context
	ID  uint
} {
	var calls []struct {
		Ctx context.Context
		ID  uint
	}
	mock.lockDeleteAuth.RLock()
	calls = mock.calls.DeleteAuth
	mock.lockDeleteAuth.RUnlock()
	return calls
}

// GetAuth calls GetAuthFunc.
func (mock *ClientMock) GetAuth(ctx context.Context, id uint) (*client.GHARepositoryAuth, error) {
	if mock.GetAuthFunc == nil {
		panic("ClientMock.GetAuthFunc: method is nil but Client.GetAuth was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uint
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetAuth.Lock()
	mock.calls.GetAuth = append(mock.calls.GetAuth, callInfo)
	mock.lockGetAuth.Unlock()
	return mock.GetAuthFunc(ctx, id)
}

// GetAuthCalls gets all the calls that were made to GetAuth.
// Check the length with:
//
//	len(mockedClient.GetAuthCalls())
func (mock *ClientMock) GetAuthCalls() []struct {
	Ctx context.Context
	ID  uint
} {
	var calls []struct {
		Ctx context.Context
		ID  uint
	}
	mock.lockGetAuth.RLock()
	calls = mock.calls.GetAuth
	mock.lockGetAuth.RUnlock()
	return calls
}

// GetAuthByRepository calls GetAuthByRepositoryFunc.
func (mock *ClientMock) GetAuthByRepository(ctx context.Context, repository string) (*client.GHARepositoryAuth, error) {
	if mock.GetAuthByRepositoryFunc == nil {
		panic("ClientMock.GetAuthByRepositoryFunc: method is nil but Client.GetAuthByRepository was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Repository string
	}{
		Ctx:        ctx,
		Repository: repository,
	}
	mock.lockGetAuthByRepository.Lock()
	mock.calls.GetAuthByRepository = append(mock.calls.GetAuthByRepository, callInfo)
	mock.lockGetAuthByRepository.Unlock()
	return mock.GetAuthByRepositoryFunc(ctx, repository)
}

// GetAuthByRepositoryCalls gets all the calls that were made to GetAuthByRepository.
// Check the length with:
//
//	len(mockedClient.GetAuthByRepositoryCalls())
func (mock *ClientMock) GetAuthByRepositoryCalls() []struct {
	Ctx        context.Context
	Repository string
} {
	var calls []struct {
		Ctx        context.Context
		Repository string
	}
	mock.lockGetAuthByRepository.RLock()
	calls = mock.calls.GetAuthByRepository
	mock.lockGetAuthByRepository.RUnlock()
	return calls
}

// GetDeployment calls GetDeploymentFunc.
func (mock *ClientMock) GetDeployment(ctx context.Context, releaseID string, deployID string) (*client.ReleaseDeployment, error) {
	if mock.GetDeploymentFunc == nil {
		panic("ClientMock.GetDeploymentFunc: method is nil but Client.GetDeployment was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ReleaseID string
		DeployID  string
	}{
		Ctx:       ctx,
		ReleaseID: releaseID,
		DeployID:  deployID,
	}
	mock.lockGetDeployment.Lock()
	mock.calls.GetDeployment = append(mock.calls.GetDeployment, callInfo)
	mock.lockGetDeployment.Unlock()
	return mock.GetDeploymentFunc(ctx, releaseID, deployID)
}

// GetDeploymentCalls gets all the calls that were made to GetDeployment.
// Check the length with:
//
//	len(mockedClient.GetDeploymentCalls())
func (mock *ClientMock) GetDeploymentCalls() []struct {
	Ctx       context.Context
	ReleaseID string
	DeployID  string
} {
	var calls []struct {
		Ctx       context.Context
		ReleaseID string
		DeployID  string
	}
	mock.lockGetDeployment.RLock()
	calls = mock.calls.GetDeployment
	mock.lockGetDeployment.RUnlock()
	return calls
}

// GetDeploymentEvents calls GetDeploymentEventsFunc.
func (mock *ClientMock) GetDeploymentEvents(ctx context.Context, releaseID string, deployID string) ([]client.DeploymentEvent, error) {
	if mock.GetDeploymentEventsFunc == nil {
		panic("ClientMock.GetDeploymentEventsFunc: method is nil but Client.GetDeploymentEvents was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ReleaseID string
		DeployID  string
	}{
		Ctx:       ctx,
		ReleaseID: releaseID,
		DeployID:  deployID,
	}
	mock.lockGetDeploymentEvents.Lock()
	mock.calls.GetDeploymentEvents = append(mock.calls.GetDeploymentEvents, callInfo)
	mock.lockGetDeploymentEvents.Unlock()
	return mock.GetDeploymentEventsFunc(ctx, releaseID, deployID)
}

// GetDeploymentEventsCalls gets all the calls that were made to GetDeploymentEvents.
// Check the length with:
//
//	len(mockedClient.GetDeploymentEventsCalls())
func (mock *ClientMock) GetDeploymentEventsCalls() []struct {
	Ctx       context.Context
	ReleaseID string
	DeployID  string
} {
	var calls []struct {
		Ctx       context.Context
		ReleaseID string
		DeployID  string
	}
	mock.lockGetDeploymentEvents.RLock()
	calls = mock.calls.GetDeploymentEvents
	mock.lockGetDeploymentEvents.RUnlock()
	return calls
}

// GetLatestDeployment calls GetLatestDeploymentFunc.
func (mock *ClientMock) GetLatestDeployment(ctx context.Context, releaseID string) (*client.ReleaseDeployment, error) {
	if mock.GetLatestDeploymentFunc == nil {
		panic("ClientMock.GetLatestDeploymentFunc: method is nil but Client.GetLatestDeployment was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ReleaseID string
	}{
		Ctx:       ctx,
		ReleaseID: releaseID,
	}
	mock.lockGetLatestDeployment.Lock()
	mock.calls.GetLatestDeployment = append(mock.calls.GetLatestDeployment, callInfo)
	mock.lockGetLatestDeployment.Unlock()
	return mock.GetLatestDeploymentFunc(ctx, releaseID)
}

// GetLatestDeploymentCalls gets all the calls that were made to GetLatestDeployment.
// Check the length with:
//
//	len(mockedClient.GetLatestDeploymentCalls())
func (mock *ClientMock) GetLatestDeploymentCalls() []struct {
	Ctx       context.Context
	ReleaseID string
} {
	var calls []struct {
		Ctx       context.Context
		ReleaseID string
	}
	mock.lockGetLatestDeployment.RLock()
	calls = mock.calls.GetLatestDeployment
	mock.lockGetLatestDeployment.RUnlock()
	return calls
}

// GetRelease calls GetReleaseFunc.
func (mock *ClientMock) GetRelease(ctx context.Context, id string) (*client.Release, error) {
	if mock.GetReleaseFunc == nil {
		panic("ClientMock.GetReleaseFunc: method is nil but Client.GetRelease was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetRelease.Lock()
	mock.calls.GetRelease = append(mock.calls.GetRelease, callInfo)
	mock.lockGetRelease.Unlock()
	return mock.GetReleaseFunc(ctx, id)
}

// GetReleaseCalls gets all the calls that were made to GetRelease.
// Check the length with:
//
//	len(mockedClient.GetReleaseCalls())
func (mock *ClientMock) GetReleaseCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetRelease.RLock()
	calls = mock.calls.GetRelease
	mock.lockGetRelease.RUnlock()
	return calls
}

// GetReleaseByAlias calls GetReleaseByAliasFunc.
func (mock *ClientMock) GetReleaseByAlias(ctx context.Context, aliasName string) (*client.Release, error) {
	if mock.GetReleaseByAliasFunc == nil {
		panic("ClientMock.GetReleaseByAliasFunc: method is nil but Client.GetReleaseByAlias was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		AliasName string
	}{
		Ctx:       ctx,
		AliasName: aliasName,
	}
	mock.lockGetReleaseByAlias.Lock()
	mock.calls.GetReleaseByAlias = append(mock.calls.GetReleaseByAlias, callInfo)
	mock.lockGetReleaseByAlias.Unlock()
	return mock.GetReleaseByAliasFunc(ctx, aliasName)
}

// GetReleaseByAliasCalls gets all the calls that were made to GetReleaseByAlias.
// Check the length with:
//
//	len(mockedClient.GetReleaseByAliasCalls())
func (mock *ClientMock) GetReleaseByAliasCalls() []struct {
	Ctx       context.Context
	AliasName string
} {
	var calls []struct {
		Ctx       context.Context
		AliasName string
	}
	mock.lockGetReleaseByAlias.RLock()
	calls = mock.calls.GetReleaseByAlias
	mock.lockGetReleaseByAlias.RUnlock()
	return calls
}

// IncrementDeploymentAttempts calls IncrementDeploymentAttemptsFunc.
func (mock *ClientMock) IncrementDeploymentAttempts(ctx context.Context, releaseID string, deployID string) (*client.ReleaseDeployment, error) {
	if mock.IncrementDeploymentAttemptsFunc == nil {
		panic("ClientMock.IncrementDeploymentAttemptsFunc: method is nil but Client.IncrementDeploymentAttempts was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ReleaseID string
		DeployID  string
	}{
		Ctx:       ctx,
		ReleaseID: releaseID,
		DeployID:  deployID,
	}
	mock.lockIncrementDeploymentAttempts.Lock()
	mock.calls.IncrementDeploymentAttempts = append(mock.calls.IncrementDeploymentAttempts, callInfo)
	mock.lockIncrementDeploymentAttempts.Unlock()
	return mock.IncrementDeploymentAttemptsFunc(ctx, releaseID, deployID)
}

// IncrementDeploymentAttemptsCalls gets all the calls that were made to IncrementDeploymentAttempts.
// Check the length with:
//
//	len(mockedClient.IncrementDeploymentAttemptsCalls())
func (mock *ClientMock) IncrementDeploymentAttemptsCalls() []struct {
	Ctx       context.Context
	ReleaseID string
	DeployID  string
} {
	var calls []struct {
		Ctx       context.Context
		ReleaseID string
		DeployID  string
	}
	mock.lockIncrementDeploymentAttempts.RLock()
	calls = mock.calls.IncrementDeploymentAttempts
	mock.lockIncrementDeploymentAttempts.RUnlock()
	return calls
}

// ListAliases calls ListAliasesFunc.
func (mock *ClientMock) ListAliases(ctx context.Context, releaseID string) ([]client.ReleaseAlias, error) {
	if mock.ListAliasesFunc == nil {
		panic("ClientMock.ListAliasesFunc: method is nil but Client.ListAliases was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ReleaseID string
	}{
		Ctx:       ctx,
		ReleaseID: releaseID,
	}
	mock.lockListAliases.Lock()
	mock.calls.ListAliases = append(mock.calls.ListAliases, callInfo)
	mock.lockListAliases.Unlock()
	return mock.ListAliasesFunc(ctx, releaseID)
}

// ListAliasesCalls gets all the calls that were made to ListAliases.
// Check the length with:
//
//	len(mockedClient.ListAliasesCalls())
func (mock *ClientMock) ListAliasesCalls() []struct {
	Ctx       context.Context
	ReleaseID string
} {
	var calls []struct {
		Ctx       context.Context
		ReleaseID string
	}
	mock.lockListAliases.RLock()
	calls = mock.calls.ListAliases
	mock.lockListAliases.RUnlock()
	return calls
}

// ListAuths calls ListAuthsFunc.
func (mock *ClientMock) ListAuths(ctx context.Context) ([]client.GHARepositoryAuth, error) {
	if mock.ListAuthsFunc == nil {
		panic("ClientMock.ListAuthsFunc: method is nil but Client.ListAuths was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListAuths.Lock()
	mock.calls.ListAuths = append(mock.calls.ListAuths, callInfo)
	mock.lockListAuths.Unlock()
	return mock.ListAuthsFunc(ctx)
}

// ListAuthsCalls gets all the calls that were made to ListAuths.
// Check the length with:
//
//	len(mockedClient.ListAuthsCalls())
func (mock *ClientMock) ListAuthsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListAuths.RLock()
	calls = mock.calls.ListAuths
	mock.lockListAuths.RUnlock()
	return calls
}

// ListDeployments calls ListDeploymentsFunc.
func (mock *ClientMock) ListDeployments(ctx context.Context, releaseID string) ([]client.ReleaseDeployment, error) {
	if mock.ListDeploymentsFunc == nil {
		panic("ClientMock.ListDeploymentsFunc: method is nil but Client.ListDeployments was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ReleaseID string
	}{
		Ctx:       ctx,
		ReleaseID: releaseID,
	}
	mock.lockListDeployments.Lock()
	mock.calls.ListDeployments = append(mock.calls.ListDeployments, callInfo)
	mock.lockListDeployments.Unlock()
	return mock.ListDeploymentsFunc(ctx, releaseID)
}

// ListDeploymentsCalls gets all the calls that were made to ListDeployments.
// Check the length with:
//
//	len(mockedClient.ListDeploymentsCalls())
func (mock *ClientMock) ListDeploymentsCalls() []struct {
	Ctx       context.Context
	ReleaseID string
} {
	var calls []struct {
		Ctx       context.Context
		ReleaseID string
	}
	mock.lockListDeployments.RLock()
	calls = mock.calls.ListDeployments
	mock.lockListDeployments.RUnlock()
	return calls
}

// ListReleases calls ListReleasesFunc.
func (mock *ClientMock) ListReleases(ctx context.Context, projectName string) ([]client.Release, error) {
	if mock.ListReleasesFunc == nil {
		panic("ClientMock.ListReleasesFunc: method is nil but Client.ListReleases was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		ProjectName string
	}{
		Ctx:         ctx,
		ProjectName: projectName,
	}
	mock.lockListReleases.Lock()
	mock.calls.ListReleases = append(mock.calls.ListReleases, callInfo)
	mock.lockListReleases.Unlock()
	return mock.ListReleasesFunc(ctx, projectName)
}

// ListReleasesCalls gets all the calls that were made to ListReleases.
// Check the length with:
//
//	len(mockedClient.ListReleasesCalls())
func (mock *ClientMock) ListReleasesCalls() []struct {
	Ctx         context.Context
	ProjectName string
} {
	var calls []struct {
		Ctx         context.Context
		ProjectName string
	}
	mock.lockListReleases.RLock()
	calls = mock.calls.ListReleases
	mock.lockListReleases.RUnlock()
	return calls
}

// UpdateAuth calls UpdateAuthFunc.
func (mock *ClientMock) UpdateAuth(ctx context.Context, id uint, req *client.UpdateAuthRequest) (*client.GHARepositoryAuth, error) {
	if mock.UpdateAuthFunc == nil {
		panic("ClientMock.UpdateAuthFunc: method is nil but Client.UpdateAuth was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uint
		Req *client.UpdateAuthRequest
	}{
		Ctx: ctx,
		ID:  id,
		Req: req,
	}
	mock.lockUpdateAuth.Lock()
	mock.calls.UpdateAuth = append(mock.calls.UpdateAuth, callInfo)
	mock.lockUpdateAuth.Unlock()
	return mock.UpdateAuthFunc(ctx, id, req)
}

// UpdateAuthCalls gets all the calls that were made to UpdateAuth.
// Check the length with:
//
//	len(mockedClient.UpdateAuthCalls())
func (mock *ClientMock) UpdateAuthCalls() []struct {
	Ctx context.Context
	ID  uint
	Req *client.UpdateAuthRequest
} {
	var calls []struct {
		Ctx context.Context
		ID  uint
		Req *client.UpdateAuthRequest
	}
	mock.lockUpdateAuth.RLock()
	calls = mock.calls.UpdateAuth
	mock.lockUpdateAuth.RUnlock()
	return calls
}

// UpdateDeployment calls UpdateDeploymentFunc.
func (mock *ClientMock) UpdateDeployment(ctx context.Context, releaseID string, deployment *client.ReleaseDeployment) (*client.ReleaseDeployment, error) {
	if mock.UpdateDeploymentFunc == nil {
		panic("ClientMock.UpdateDeploymentFunc: method is nil but Client.UpdateDeployment was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ReleaseID  string
		Deployment *client.ReleaseDeployment
	}{
		Ctx:        ctx,
		ReleaseID:  releaseID,
		Deployment: deployment,
	}
	mock.lockUpdateDeployment.Lock()
	mock.calls.UpdateDeployment = append(mock.calls.UpdateDeployment, callInfo)
	mock.lockUpdateDeployment.Unlock()
	return mock.UpdateDeploymentFunc(ctx, releaseID, deployment)
}

// UpdateDeploymentCalls gets all the calls that were made to UpdateDeployment.
// Check the length with:
//
//	len(mockedClient.UpdateDeploymentCalls())
func (mock *ClientMock) UpdateDeploymentCalls() []struct {
	Ctx        context.Context
	ReleaseID  string
	Deployment *client.ReleaseDeployment
} {
	var calls []struct {
		Ctx        context.Context
		ReleaseID  string
		Deployment *client.ReleaseDeployment
	}
	mock.lockUpdateDeployment.RLock()
	calls = mock.calls.UpdateDeployment
	mock.lockUpdateDeployment.RUnlock()
	return calls
}

// UpdateRelease calls UpdateReleaseFunc.
func (mock *ClientMock) UpdateRelease(ctx context.Context, release *client.Release) (*client.Release, error) {
	if mock.UpdateReleaseFunc == nil {
		panic("ClientMock.UpdateReleaseFunc: method is nil but Client.UpdateRelease was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Release *client.Release
	}{
		Ctx:     ctx,
		Release: release,
	}
	mock.lockUpdateRelease.Lock()
	mock.calls.UpdateRelease = append(mock.calls.UpdateRelease, callInfo)
	mock.lockUpdateRelease.Unlock()
	return mock.UpdateReleaseFunc(ctx, release)
}

// UpdateReleaseCalls gets all the calls that were made to UpdateRelease.
// Check the length with:
//
//	len(mockedClient.UpdateReleaseCalls())
func (mock *ClientMock) UpdateReleaseCalls() []struct {
	Ctx     context.Context
	Release *client.Release
} {
	var calls []struct {
		Ctx     context.Context
		Release *client.Release
	}
	mock.lockUpdateRelease.RLock()
	calls = mock.calls.UpdateRelease
	mock.lockUpdateRelease.RUnlock()
	return calls
}

// ValidateToken calls ValidateTokenFunc.
func (mock *ClientMock) ValidateToken(ctx context.Context, req *client.ValidateTokenRequest) (*client.ValidateTokenResponse, error) {
	if mock.ValidateTokenFunc == nil {
		panic("ClientMock.ValidateTokenFunc: method is nil but Client.ValidateToken was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *client.ValidateTokenRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockValidateToken.Lock()
	mock.calls.ValidateToken = append(mock.calls.ValidateToken, callInfo)
	mock.lockValidateToken.Unlock()
	return mock.ValidateTokenFunc(ctx, req)
}

// ValidateTokenCalls gets all the calls that were made to ValidateToken.
// Check the length with:
//
//	len(mockedClient.ValidateTokenCalls())
func (mock *ClientMock) ValidateTokenCalls() []struct {
	Ctx context.Context
	Req *client.ValidateTokenRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *client.ValidateTokenRequest
	}
	mock.lockValidateToken.RLock()
	calls = mock.calls.ValidateToken
	mock.lockValidateToken.RUnlock()
	return calls
}
