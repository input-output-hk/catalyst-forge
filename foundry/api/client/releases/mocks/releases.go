// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/input-output-hk/catalyst-forge/foundry/api/client/releases"
	"sync"
)

// Ensure, that ReleasesClientInterfaceMock does implement releases.ReleasesClientInterface.
// If this is not the case, regenerate this file with moq.
var _ releases.ReleasesClientInterface = &ReleasesClientInterfaceMock{}

// ReleasesClientInterfaceMock is a mock implementation of releases.ReleasesClientInterface.
//
//	func TestSomethingThatUsesReleasesClientInterface(t *testing.T) {
//
//		// make and configure a mocked releases.ReleasesClientInterface
//		mockedReleasesClientInterface := &ReleasesClientInterfaceMock{
//			CreateFunc: func(ctx context.Context, release *releases.Release, deploy bool) (*releases.Release, error) {
//				panic("mock out the Create method")
//			},
//			GetFunc: func(ctx context.Context, id string) (*releases.Release, error) {
//				panic("mock out the Get method")
//			},
//			GetByAliasFunc: func(ctx context.Context, aliasName string) (*releases.Release, error) {
//				panic("mock out the GetByAlias method")
//			},
//			ListFunc: func(ctx context.Context, projectName string) ([]releases.Release, error) {
//				panic("mock out the List method")
//			},
//			UpdateFunc: func(ctx context.Context, release *releases.Release) (*releases.Release, error) {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedReleasesClientInterface in code that requires releases.ReleasesClientInterface
//		// and then make assertions.
//
//	}
type ReleasesClientInterfaceMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, release *releases.Release, deploy bool) (*releases.Release, error)

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, id string) (*releases.Release, error)

	// GetByAliasFunc mocks the GetByAlias method.
	GetByAliasFunc func(ctx context.Context, aliasName string) (*releases.Release, error)

	// ListFunc mocks the List method.
	ListFunc func(ctx context.Context, projectName string) ([]releases.Release, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, release *releases.Release) (*releases.Release, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Release is the release argument value.
			Release *releases.Release
			// Deploy is the deploy argument value.
			Deploy bool
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetByAlias holds details about calls to the GetByAlias method.
		GetByAlias []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AliasName is the aliasName argument value.
			AliasName string
		}
		// List holds details about calls to the List method.
		List []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProjectName is the projectName argument value.
			ProjectName string
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Release is the release argument value.
			Release *releases.Release
		}
	}
	lockCreate     sync.RWMutex
	lockGet        sync.RWMutex
	lockGetByAlias sync.RWMutex
	lockList       sync.RWMutex
	lockUpdate     sync.RWMutex
}

// Create calls CreateFunc.
func (mock *ReleasesClientInterfaceMock) Create(ctx context.Context, release *releases.Release, deploy bool) (*releases.Release, error) {
	if mock.CreateFunc == nil {
		panic("ReleasesClientInterfaceMock.CreateFunc: method is nil but ReleasesClientInterface.Create was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Release *releases.Release
		Deploy  bool
	}{
		Ctx:     ctx,
		Release: release,
		Deploy:  deploy,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, release, deploy)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedReleasesClientInterface.CreateCalls())
func (mock *ReleasesClientInterfaceMock) CreateCalls() []struct {
	Ctx     context.Context
	Release *releases.Release
	Deploy  bool
} {
	var calls []struct {
		Ctx     context.Context
		Release *releases.Release
		Deploy  bool
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *ReleasesClientInterfaceMock) Get(ctx context.Context, id string) (*releases.Release, error) {
	if mock.GetFunc == nil {
		panic("ReleasesClientInterfaceMock.GetFunc: method is nil but ReleasesClientInterface.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, id)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedReleasesClientInterface.GetCalls())
func (mock *ReleasesClientInterfaceMock) GetCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetByAlias calls GetByAliasFunc.
func (mock *ReleasesClientInterfaceMock) GetByAlias(ctx context.Context, aliasName string) (*releases.Release, error) {
	if mock.GetByAliasFunc == nil {
		panic("ReleasesClientInterfaceMock.GetByAliasFunc: method is nil but ReleasesClientInterface.GetByAlias was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		AliasName string
	}{
		Ctx:       ctx,
		AliasName: aliasName,
	}
	mock.lockGetByAlias.Lock()
	mock.calls.GetByAlias = append(mock.calls.GetByAlias, callInfo)
	mock.lockGetByAlias.Unlock()
	return mock.GetByAliasFunc(ctx, aliasName)
}

// GetByAliasCalls gets all the calls that were made to GetByAlias.
// Check the length with:
//
//	len(mockedReleasesClientInterface.GetByAliasCalls())
func (mock *ReleasesClientInterfaceMock) GetByAliasCalls() []struct {
	Ctx       context.Context
	AliasName string
} {
	var calls []struct {
		Ctx       context.Context
		AliasName string
	}
	mock.lockGetByAlias.RLock()
	calls = mock.calls.GetByAlias
	mock.lockGetByAlias.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *ReleasesClientInterfaceMock) List(ctx context.Context, projectName string) ([]releases.Release, error) {
	if mock.ListFunc == nil {
		panic("ReleasesClientInterfaceMock.ListFunc: method is nil but ReleasesClientInterface.List was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		ProjectName string
	}{
		Ctx:         ctx,
		ProjectName: projectName,
	}
	mock.lockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	mock.lockList.Unlock()
	return mock.ListFunc(ctx, projectName)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//
//	len(mockedReleasesClientInterface.ListCalls())
func (mock *ReleasesClientInterfaceMock) ListCalls() []struct {
	Ctx         context.Context
	ProjectName string
} {
	var calls []struct {
		Ctx         context.Context
		ProjectName string
	}
	mock.lockList.RLock()
	calls = mock.calls.List
	mock.lockList.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *ReleasesClientInterfaceMock) Update(ctx context.Context, release *releases.Release) (*releases.Release, error) {
	if mock.UpdateFunc == nil {
		panic("ReleasesClientInterfaceMock.UpdateFunc: method is nil but ReleasesClientInterface.Update was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Release *releases.Release
	}{
		Ctx:     ctx,
		Release: release,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, release)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedReleasesClientInterface.UpdateCalls())
func (mock *ReleasesClientInterfaceMock) UpdateCalls() []struct {
	Ctx     context.Context
	Release *releases.Release
} {
	var calls []struct {
		Ctx     context.Context
		Release *releases.Release
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}
